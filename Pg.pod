
=encoding euc-jp

=head1 NAME

=begin original

DBD::Pg - PostgreSQL database driver for the DBI module

=end original

DBD::Pg - DBI モジュールのための PostgreSQL データベース・ドライバ

=head1 SYNOPSIS

=begin original

  use DBI;

  $dbh = DBI->connect("dbi:Pg:dbname=$dbname", '', '', {AutoCommit => 0});
  # The AutoCommit attribute should always be explicitly set

  # For some advanced uses you may need PostgreSQL type values:
  use DBD::Pg qw(:pg_types);

  # For asynchronous calls, import the async constants:
  use DBD::Pg qw(:async);

  $dbh->do('INSERT INTO mytable(a) VALUES (1)');

  $sth = $dbh->prepare('INSERT INTO mytable(a) VALUES (?)');
  $sth->execute();

=end original

  use DBI;

  $dbh = DBI->connect("dbi:Pg:dbname=$dbname", '', '', {AutoCommit => 0});
  # AutoCommit 属性は、常に明示的に設定すべきです

  # より高度な使い方のためには PostgreSQL のデータ型の値が必要かもしれません:
  use DBD::Pg qw(:pg_types);

  # 非同期呼び出しのために、非同期関連の定数をインポートします:
  use DBD::Pg qw(:async);

  $dbh->do('INSERT INTO mytable(a) VALUES (1)');

  $sth = $dbh->prepare('INSERT INTO mytable(a) VALUES (?)');
  $sth->execute();

  (訳注: いきなりエラーじゃないのか？この最後の2行)

=head1 VERSION

=begin original

This documents version 2.17.1 of the DBD::Pg module

=end original

このドキュメントは DBD::Pg モジュールのバージョン 2.17.1 のものです。

=head1 DESCRIPTION

=begin original

DBD::Pg is a Perl module that works with the DBI module to provide access to
PostgreSQL databases.

=end original

DBD::Pg は DBI モジュールと一緒に機能し、PostgreSQL
データベースへのアクセスを提供する Perl モジュールです。

=head1 MODULE DOCUMENTATION

=begin original

This documentation describes driver specific behavior and restrictions. It is
not supposed to be used as the only reference for the user. In any case
consult the B<DBI> documentation first!

=end original

このドキュメントはドライバ独自の動きおよび制限を説明します。
ユーザのための唯一のリファレンスとして使われることを想定していません。
いかなる場合でも、まず B<DBI> のドキュメントを調べてください!

=for html <a href="http://search.cpan.org/~timb/DBI/DBI.pm">Latest DBI docmentation.</a>

=head1 THE DBI CLASS

=head2 DBI Class Methods

=head3 B<connect>

=begin original

This method creates a database handle by connecting to a database,
and is the DBI equivalent of the "new" method.
To connect to a Postgres database with a minimum of parameters, 
use the following syntax:

=end original

このメソッドはデータベースへ接続し、データベースハンドルを返します。
このメソッドは、一般のモジュールの "new" メソッドに相当するものです。
Postgres のデータベースに最小限のパラメータで接続するには、以下のように書きます:

  $dbh = DBI->connect("dbi:Pg:dbname=$dbname", '', '', {AutoCommit => 0});

=begin original

This connects to the database named in the C<$dbname> variable
on the default port (usually 5432) without any user authentication.

=end original

これは、デフォルトのポート(通常は 5432)上の、名前が変数
C<$dbname> に指定されているデータベースに、ユーザ認証なしで接続します。

=begin original

The following connect statement shows almost all possible parameters:

=end original

以下の connect ステートメントは、ほとんどすべての使用可能なパラメータを表しています:

  $dbh = DBI->connect("dbi:Pg:dbname=$dbname;host=$host;port=$port;options=$options",
                      $username,
                      $password,
                      {AutoCommit => 0, RaiseError => 1, PrintError => 0}
                      );

=begin original

If a parameter is not given, the connect() method will first look for 
specific environment variables, and then fall back to hard-coded defaults:

  parameter    environment variable    hard coded default
  ------------------------------------------------------
  host         PGHOST                  local domain socket
  hostaddr     PGHOSTADDR              local domain socket
  port         PGPORT                  5432
  dbname*      PGDATABASE              current userid
  username     PGUSER                  current userid
  password     PGPASSWORD              (none)
  options      PGOPTIONS               (none)
  service      PGSERVICE               (none)
  sslmode      PGSSLMODE               (none)

* May also use the aliases C<db> or C<database>

=end original

パラメータが与えられなければ、connect() メソッドはまず特定の環境変数を探し、
それからハード・コードされたデフォルトを使います:

  パラメータ   環境変数　　　　  　    ハード・コードされたデフォルト
  ------------------------------------------------------
  host         PGHOST                  ローカルのドメイン・ソケット
  hostaddr     PGHOSTADDR              ローカルのドメイン・ソケット
  port         PGPORT                  5432
  dbname*      PGDATABASE              現在のユーザ ID
  username     PGUSER                  現在のユーザ ID
  password     PGPASSWORD              (none)
  options      PGOPTIONS               (none)
  service      PGSERVICE               (none)
  sslmode      PGSSLMODE               (none)

* C<dbname> の別名として、C<db> や C<database> を使うことも出来ます。

=begin original

If the username and password values passed via C<connect()> are undefined (as opposed 
to merely being empty strings), DBI will use the environment variables I<DBI_USER> 
and I<DBI_PASS> if they exist.

=end original

C<connect()> に渡されたユーザ名やパスワードが未定義値だった場合、
(未定義値は、単なる空の文字列とはまったく違うものです)
DBI は環境変数 I<DBI_USER> や I<DBI_PASS> が存在していればその値を使用します。

=begin original

You can also connect by using a service connection file, which is named 
F<pg_service.conf>. The location of this file can be controlled by 
setting the I<PGSYSCONFDIR> environment variable. To use one of the named 
services within the file, set the name by using either the I<service> parameter 
or the environment variable I<PGSERVICE>. Note that when connecting this way, 
only the minimum parameters should be used. For example, to connect to a 
service named "zephyr", you could use:

  $dbh = DBI->connect("dbi:Pg:service=zephyr", '', '');

=end original

F<pg_service.conf> という名前の接続サービスファイルを用いて接続することも可能です。
このファイルの場所を、環境変数 I<PGSYSCONFDIR> によって指定することができます。
この方法で接続する場合は、最小限のパラメータを使用するだけでよいことに注意してください。
例えば、"zephyr" という名前のサービスに接続するには、以下のように書くことが出来ます:

  $dbh = DBI->connect("dbi:Pg:service=zephyr", '', '');

=begin original

You could also set C<$ENV{PGSERVICE}> to "zephyr" and connect like this:

  $dbh = DBI->connect("dbi:Pg:", '', '');

=end original

環境変数 C<$ENV{PGSERVICE}> を "zephyr"
と設定することで、このように接続することも出来ます:

  $dbh = DBI->connect("dbi:Pg:", '', '');

=begin original

The format of the F<pg_service.conf> file is simply a bracketed service 
name, followed by one parameter per line in the format name=value.
For example:

  [zephyr]
  dbname=winds
  user=wisp
  password=W$2Hc00YSgP
  port=6543

=end original

F<pg_service.conf> のフォーマットは、単純に、ブラケットに囲まれたサービス名、
引き続き、name=value 形式のパラメータ行を一行に一つずつです。
例を示します:

  [zephyr]
  dbname=winds
  user=wisp
  password=W$2Hc00YSgP
  port=6543

=begin original

There are four valid arguments to the I<sslmode> parameter, which controls 
whether to use SSL to connect to the database:

=over 4

=item * disable: SSL connections are never used

=item * allow: try non-SSL, then SSL

=item * prefer: try SSL, then non-SSL

=item * require: connect only with SSL

=back

=end original

データベースに接続する際に SSL を使用するかどうかをコントロールするには
I<sslmode> パラメータを使用します。ここに指定できる値は 4 種類あります:

=over 4

=item * disable: SSL 接続をしません

=item * allow: まず SSL 無しで接続を試み、失敗した場合 SSL 接続を行います

=item * prefer: まず SSL 接続を試み、失敗した場合 SSL 無しの接続を行います

=item * require: SSL 接続だけを行います

=back

=begin original

You can also connect using sockets in a specific directory. This 
may be needed if the server you are connecting to has a different 
default socket directory from the one used to compile DBD::Pg. 
Use the complete path to the socket directory as the name of the 
host, like this:

=end original

ディレクトリを指定して、その中にあるソケットに接続することも出来ます。
あなたが接続しようとしているサーバが、
DBD::Pg をコンパイルしたときに使用したディレクトリとは別のディレクトリを
デフォルトのソケット・ディレクトリとしている場合にこれが必要になるでしょう。
ホスト名として、ソケットディレクトリの完全なパスを指定してください。
次のように書きます:

  $dbh = DBI->connect('dbi:Pg:dbname=foo;host=/var/tmp/socket',
    $username,
    $password,
    {AutoCommit => 0, RaiseError => 1});

=begin original

The attribute hash can also contain a key named C<dbd_verbose>, which 
simply calls C<< $dbh->trace('DBD') >> after the handle is created. This attribute 
is not recommended, as it is clearer to simply explicitly call C<trace> explicitly 
in your script.

=end original

属性を指定しているハッシュのキーに、C<dbd_verbose> を指定することもでき、
指定すると、ハンドルが生成された後に C<< $dbh->trace('DBD') >>
を呼び出します。スクリプトの中で明示的に C<trace>
を呼び出したほうが明瞭ですので、この属性の使用は奨励されません。

=head3 B<connect_cached>

=begin original

  $dbh = DBI->connect_cached("dbi:Pg:dbname=$dbname", $username, $password, \%options);

Implemented by DBI, no driver-specific impact.

=end original

  $dbh = DBI->connect_cached("dbi:Pg:dbname=$dbname", $username, $password, \%options);

DBI によって実装されており、ドライバ特有の影響はありません。

=head3 B<data_sources>

=begin original

  @data_sources = DBI->data_sources('Pg');
  @data_sources = $dbh->data_sources();

Returns a list of available databases.
Unless the environment variable C<DBI_DSN> is set, 
a connection will be attempted to the database C<template1>.
The normal connection environment variables also apply,
such as C<PGHOST>, C<PGPORT>, C<DBI_USER>, C<DBI_PASS>, and C<PGSERVICE>.

=end original

  @data_sources = DBI->data_sources('Pg');
  @data_sources = $dbh->data_sources();

有効なデータベースのリストを返します。環境変数 C<DBI_DSN> が設定されていなければ、
データベース C<template1> への接続が試みられます。
C<PGHOST>, C<PGPORT>, C<DBI_USER>, C<DBI_PASS>, C<PGSERVICE>
といった、接続に関する通常の環境変数も適用されます。

=begin original

You can also pass in options to add to the connection string For example,
to specify an alternate port and host:

=end original

接続文字列にオプションを追加して渡すことも出来ます。
例えば、別なポートとホストを指定するには:

  @data_sources = DBI->data_sources('Pg', 'port=5824;host=example.com');

  or:

  @data_sources = $dbh->data_sources('port=5824;host=example.com');

=head2 Methods Common To All Handles
(全てのハンドルに共通のメソッド)

=begin original

For all of the methods below, B<$h> can be either a database handle (B<$dbh>) 
or a statement handle (B<$sth>). Note that I<$dbh> and I<$sth> can be replaced with 
any variable name you choose: these are just the names most often used. Another 
common variable used in this documentation is $I<rv>, which stands for "return value".

=end original

下記に示す全てのメソッドにある B<$h> は、データベースハンドル (B<$dbh>)
にも、ステートメントハンドル (B<$sth>) にもあてはまります。
I<$dbh> と I<$sth> は、単によく使われる変数名であって、
あなたが選んだほかの変数名に置き換えてもよい、ということに注意してください。
このドキュメントによく出てくる変数名としては、$I<rv> もあります。
これは、"return value" の頭文字です。

=head3 B<err>

  $rv = $h->err;

=begin original

Returns the error code from the last method called.
For the connect method it returns C<PQstatus>,
which is a number used by I<libpq> (the Postgres connection library).
A value of 0 indicates no error (CONNECTION_OK),
while any other number indicates a failed connection.
The only other number commonly seen is 1 (CONNECTION_BAD).
See the libpq documentation for the complete list of return codes.

=end original

最後に呼ばれたメソッドのエラーコードを返します。
connect メソッドの後では、I<libpq> (PostgreSQL インタフェースライブラリ)
で使われている数値が返されます。
値 0 はエラーが無いこと (CONNECTION_OK) を示します。
ほかの値は接続に失敗したことを示します。
通常見られる 0 でない値は 1 (CONNECTION_BAD) です。
リターンコードの完全なリストは libpq のドキュメントにあります。

=begin original

In all other non-connect methods C<< $h->err >> returns the
C<PQresultStatus> of the current handle.
This is a number used by libpq and is one of:

  0  Empty query string
  1  A command that returns no data successfully completed.
  2  A command that returns data sucessfully completed.
  3  A COPY OUT command is still in progress.
  4  A COPY IN command is still in progress.
  5  A bad response was received from the backend.
  6  A nonfatal error occurred (a notice or warning message)
  7  A fatal error was returned: the last query failed.

=end original

connct メソッド以外の全てのメソッドの後では、C<< $h->err >>
は現在のハンドルの C<PQresultStatus> を返します。
この数値は libpq で使用されているもので、以下のうちのどれかです:

  0  サーバに送信された文字列が空でした。
  1  データを返さないコマンドが正常終了しました。
  2  データを返すコマンド(SELECTやSHOWなど)が正常終了しました。
  3  (サーバからの)コピーアウトデータ転送が始まりました。
  4  (サーバへの)コピーインデータ転送が始まりました。
  5  サーバが不明な応答を返しました。
  6  致命的ではない(注意喚起もしくは警告)エラーが発生しました。
  7  致命的なエラーが発生しました。最後のクエリは失敗しました。

=head3 B<errstr>

  $str = $h->errstr;

=begin original

Returns the last error that was reported by Postgres.
This message is affected by the L</pg_errorlevel> setting.

=end original

Postgres によって報告された最後のエラーメッセージを返します。
このメッセージは L</pg_errorlevel> 設定の影響を受けます。

=head3 B<state>

  $str = $h->state;

=begin original

Returns a five-character "SQLSTATE" code. Success is indicated by a C<00000> code, which 
gets mapped to an empty string by DBI. A code of C<S8006> indicates a connection failure, 
usually because the connection to the Postgres server has been lost.

While this method can be called as either C<< $sth->state >> or C<< $dbh->state >>, it 
is usually clearer to always use C<< $dbh->state >>.

The list of codes used by PostgreSQL can be found at:
L<http://www.postgresql.org/docs/current/static/errcodes-appendix.html>

Note that these codes are part of the SQL standard and only a small number 
of them will be used by PostgreSQL.  
Common codes:

  00000 Successful completion
  25P01 No active SQL transaction
  25P02 In failed SQL transaction
  S8006 Connection failure

=end original

5 文字の "SQLSTATE" コードを返します。成功は C<00000> で示されますが、
DBI によって空の文字列に置き換えられます。
コード C<S8006> は接続の失敗、通常は Postgres サーバへの接続が失われたことを示します。

このメソッドは C<< $sth->state >> と C<< $dbh->state >> のどちらからでも呼べます。
常に C<< $dbh->state >> を使うよりは、それぞれを使い分けたほうが明瞭でしょう。

PostgreSQL で使用されているコードのリストは、ここで見つけることが出来ます:
L<http://www.postgresql.org/docs/current/static/errcodes-appendix.html>

(訳注: 日本語版のURLも書いとくか)

これらのコードは SQL 標準の一部であり、そのうちのほんの一部分が
PostgreSQL によって使用されています。
共通のコード:

  00000 正常終了
  25P01 活動中のSQLトランザクションが存在しない
  25P02 失敗したSQLトランザクション内である
  S8006 接続に失敗した

(訳注: S8006 って、08006 の間違いか？)

=head3 B<trace>

  $h->trace($trace_settings);
  $h->trace($trace_settings, $trace_filename);
  $trace_settings = $h->trace;

=begin original

Changes the trace settings on a database or statement handle. 
The optional second argument specifies a file to write the 
trace information to. If no filename is given, the information 
is written to F<STDERR>. Note that tracing can be set globally as 
well by setting C<< DBI->trace >>, or by using the environment 
variable I<DBI_TRACE>.

The value is either a numeric level or a named flag. For the 
flags that DBD::Pg uses, see L<parse_trace_flag|/parse_trace_flag and parse_trace_flags>.

=end original

データベース、またはステートメントハンドルのトレース設定を変更します。
2つ目の引数で、トレース情報を書き込むファイルを指定します。
ファイル名が与えられない場合、情報は F<STDERR> に書き込まれます。
トレースの設定は C<< DBI->trace >> でグローバルに設定したり、
環境変数 I<DBI_TRACE> でも設定できることに注意してください。

(訳注: グローバルな設定しかできないっぽい。
複数のステートメントハンドルに異なる出力先を指定しておいて。
とやってみると、最後に指定した出力先に全部書き出された)

=begin original

The value is either a numeric level or a named flag. For the 
flags that DBD::Pg uses, see L<parse_trace_flag|/parse_trace_flag and parse_trace_flags>.

=end original

値は、レベルの数字とフラグ名のどちらでも指定できます。DBD::Pg
が使用しているフラグについては L<parse_trace_flag|/parse_trace_flag and parse_trace_flags>
を見てください。

=head3 B<trace_msg>

  $h->trace_msg($message_text);
  $h->trace_msg($message_text, $min_level);

=begin original

Writes a message to the current trace output (as set by the L</trace> method).
If a second argument is given, the message is only written
if the current tracing level is equal to or greater than the C<$min_level>.

=end original

現在のトレースの (L</trace> メソッドで指定された) 出力先にメッセージを書き込みます。
2つ目の引数 C<$min_level> が与えられた場合は、現在のトレースレベルが C<$min_level>
より大きいか等しい時にのみ、メッセージは書き込まれます。

=head3 B<parse_trace_flag> and B<parse_trace_flags>

  $h->trace($h->parse_trace_flags('SQL|pglibpq'));
  $h->trace($h->parse_trace_flags('1|pgstart'));

  ## Simpler:
  $h->trace('SQL|pglibpq');
  $h->trace('1|pgstart');

  my $value = DBD::Pg->parse_trace_flag('pglibpq');
  DBI->trace($value);

=begin original

The parse_trace_flags method is used to convert one or more named 
flags to a number which can passed to the L</trace> method.
DBD::Pg currently supports the DBI-specific flag, C<SQL>, 
as well as the ones listed below.

Flags can be combined by using the parse_trace_flags method, 
which simply calls C<parse_trace_flag> on each item and 
combines them.

Sometimes you may wish to turn the tracing on before you connect 
to the database. The second example above shows a way of doing this: 
the call to C<< DBD::Pg->parse_trace_flags >> provides a number than can 
be fed to C<< DBI->trace >> before you create a database handle.

=end original

C<parse_trace_flags> メソッドは１つ以上のフラグ名を、
L</trace> メソッドに渡すことが出来る数値に変換します。
DBD::Pg は下に列挙してあるフラグはもちろん、
DBI 特有のフラグである C<SQL> もサポートしています。

複数のフラグを (訳注: 文字 C<|> でつなげることによって)
組み合わせて、C<parse_trace_flags> を呼ぶことができます。
(訳注: 内部的には) それぞれのフラグ毎に C<parse_trace_flag> を呼んで
結果を組み合わせています。

データベースに接続する前に、トレースを有効にしたいことがあるかもしれません。
上の2つ目の例では、その方法を示しています:
C<< DBD::Pg->parse_trace_flags >> の呼び出しで C<< DBI->trace >>
に与えることができる数値をデータベースハンドルを生成するより前に得ています。

=begin original

DBD::Pg supports the following trace flags:

=end original

DBD::Pg は以下のトレースフラグをサポートしています:

=over 4

=item SQL

=begin original

Outputs all SQL statements. Note that the output provided will not 
necessarily be in a form suitable to passing directly to Postgres, 
as server-side prepared statements are used extensively by DBD::Pg.
For maximum portability of output (but with a potential performance 
hit), use with C<< $dbh->{pg_server_prepare} = 0 >>.

=end original

全ての SQL ステートメントを出力します。
DBD::Pg では、サーバサイドの PREPARED 文を広範囲に使用しているので、
ここで得られる出力が、必ずしも Postgres に直接渡される形式とはならないことに注意してください。
出力のポータビリティを最大にするためには、(パフォーマンスに影響する可能性はありますが)
C<< $dbh->{pg_server_prepare} = 0 >> と共に使用してください。

(訳注: XXX)

=item DBD

=begin original

Turns on all non-DBI flags, in other words, only the ones that are specific 
to DBD::Pg (all those below which start with the letters 'pg').

=end original

DBI 特有のフラグ以外を、全て有効にします。言い換えると、DBD::Pg
特有のフラグ (以下に示している 'pg' で始まるもの全て) を有効にします。

=item pglibpq

=begin original

Outputs the name of each libpq function (without arguments) immediately 
before running it. This is a good way to trace the flow of your program 
at a low level. This information is also output if the trace level 
is set to 4 or greater.

=end original

libpq 関数の名前を、実行する前に出力します。(引数は出力しません)
これは、あなたのプログラムの低レベルにおける流れをトレースするよい方法です。
この情報は、トレースレベルを 4 かそれ以上に設定することによっても出力されます。

=item pgstart

=begin original

Outputs the name of each internal DBD::Pg function, and other information such as 
the function arguments or important global variables, as each function starts. This 
information is also output if the trace level is set to 4 or greater.

=end original

DBD::Pg 内部の関数名、関数の引数や重要なグローバル変数といった情報を、
関数が開始する度に出力します。
この情報は、トレースレベルを 4 かそれ以上に設定することによっても出力されます。

=item pgend

=begin original

Outputs a simple message at the very end of each internal DBD::Pg function. This is also 
output if the trace level is set to 4 or greater.

=end original

DBD::Pg 内部の関数が終了するたびに、シンプルなメッセージを出力します。
これは、トレースレベルを 4 かそれ以上に設定することによっても出力されます。

=item pgprefix

=begin original

Forces each line of trace output to begin with the string B<C<dbdpg: >>. This helps to 
differentiate it from the normal DBI trace output.

=end original

トレースの出力の各行を、文字列 B<C<dbdpg: >> で開始するようにします。
DBI のトレース出力と区別するのに役立ちます。

=item pglogin

=begin original

Outputs a message showing the connection string right before a new database connection 
is attempted, a message when the connection was successful, and a message right after 
the database has been disconnected. Also output if trace level is 5 or greater.

=end original

データベースへの接続を試みる直前に接続文字列を伴うメッセージを、
データベースへの接続が成功した時にメッセージを、
データベースとの接続を断った直後にメッセージを、出力します。
トレースレベルを 5 かそれ以上に設定することによっても出力されます。

=back

=begin original

=for text See the DBI section on TRACING for more information.

=for html See the <a href="http://search.cpan.org/~timb/DBI/DBI.pm#TRACING">DBI section on TRACING</a> for more information.<br />

=end original

=for text より詳しい情報は、DBI の TRACING のセクションにあります。

=for html より詳しい情報は、<a href="http://search.cpan.org/~timb/DBI/DBI.pm#TRACING">DBI の TRACING のセクション</a> にあります。<br />

=head3 B<func>

=begin original

DBD::Pg uses the C<func> method to support a variety of functions. 
Note that the name of the function comes I<last>, after the arguments.

=end original

DBD::Pg はさまざまな関数をサポートするために C<func> メソッドを使用します。
関数名は、引数の後ろに、I<最後に>来ることに注意してください。

=over

=item table_attributes

  $attrs = $dbh->func($table, 'table_attributes');

=begin original

Use of the tables_attributes function is no longer recommended. Instead,
you can use the more portable C<column_info> and C<primary_key> methods
to access the same information.

=end original

table_attributes 関数の使用は、現在では奨励されていません。
同様の情報にアクセスするためには、代わりに、より可搬性のある
C<column_info> や C<primary_key> メソッドを使うことが出来ます。

=begin original

The table_attributes method returns, for the given table argument, a
reference to an array of hashes, each of which contains the following keys:

  NAME        attribute name
  TYPE        attribute type
  SIZE        attribute size (-1 for variable size)
  NULLABLE    flag nullable
  DEFAULT     default value
  CONSTRAINT  constraint
  PRIMARY_KEY flag is_primary_key
  REMARKS     attribute description

=end original

table_attributes メソッドは、引数として与えられたテーブルの情報を含む、
ハッシュの配列へのリファレンスを返します。各ハッシュには次のキーがあります:

  NAME        属性の名前
  TYPE        属性の型
  SIZE        属性のサイズ (可変の場合は -1)
  NULLABLE    nullable フラグ
  DEFAULT     デフォルト値
  CONSTRAINT  制約
  PRIMARY_KEY is_primary_key フラグ
  REMARKS     属性の説明

=item pg_lo_creat

  $lobjId = $dbh->pg_lo_creat($mode);

=begin original

Creates a new large object and returns the object-id. C<$mode> is a bitmask
describing read and write access to the new object. This setting is ignored
since Postgres version 8.1. For backwards compatibility, however, you should 
set a valid mode anyway (see L</pg_lo_open> for a list of valid modes).

=end original

新しくラージオブジェクトを生成し、その object-id を返します。
C<$mode> はこの新しいオブジェクトへの読み書きアクセスを指定するビットマスクです。
この設定は Postgres のバージョン 8.1 以降では無視されます。
しかし、以前のリリースとの後方互換性を保持するために正しいモードを指定すべきです。
(正しいモードのリストは L</pg_lo_open> にあります。)

=begin original

Upon failure it returns C<undef>. This function cannot be used if AutoCommit is enabled.

The old way of calling large objects functions is deprecated: $dbh->func(.., 'lo_);

=end original

失敗した場合は C<undef> が返されます。この関数は AutoCommit が有効な場合は使用できません。

ラージオブジェクト関数の古い使い方は deprecated です: C<< $dbh->func(..., 'lo_); >>

=item lo_open

  $lobj_fd = $dbh->pg_lo_open($lobjId, $mode);

=begin original

Opens an existing large object and returns an object-descriptor for use in
subsequent C<lo_*> calls. C<$mode> is a bitmask describing read and write
access to the opened object. It may be one of: 

=end original

既存のラージオブジェクトをオープンし、引き続く C<lo_*>
呼び出しで使うためのオブジェクト記述子を返します。
C<$mode> はオープンしたオブジェクトへの読み書きアクセスを指定するビットマスクで、
次のうちのどれかです:

  $dbh->{pg_INV_READ}
  $dbh->{pg_INV_WRITE}
  $dbh->{pg_INV_READ} | $dbh->{pg_INV_WRITE}

=begin original

C<pg_INV_WRITE> and C<pg_INV_WRITE | pg_INV_READ> modes are identical; in
both modes, the large object can be read from or written to.
Reading from the object will provide the object as written in other committed
transactions, along with any writes performed by the current transaction.
Objects opened with C<pg_INV_READ> cannot be written to. Reading from this
object will provide the stored data at the time of the transaction snapshot
which was active when C<lo_write> was called.

=end original

C<pg_INV_WRITE> と C<pg_INV_WRITE | pg_INV_READ> は区別されません。
どちらのモードも、ラージオブジェクトの読み込み、書き込みができます。
このモードで開いたオブジェクトから読み取ると、
他のトランザクションがコミットした書き込みや、
現在のトランザクションによる書き込みすべてを反映したデータを読むことになります。

C<pg_INV_READ> でオープンしたオブジェクトには書き込むことはできません。
このモードで開いたオブジェクトを読み取ると、C<lo_open>
を実行した時に有効だったトランザクションスナップショットの時点の
ラージオブジェクトの内容を読むことになります。

(訳注: 原文の C<lo_write> は明らかに C<lo_open> の間違い。
see. postgres-pg844doc-j/31.3.4. 既存のラージオブジェクトのオープン)

=begin original

Returns C<undef> upon failure. Note that 0 is a perfectly correct (and common)
object descriptor! This function cannot be used if AutoCommit is enabled.

=end original

失敗した場合には C<undef> が返されます。
0 が完全に正しい (そして、ありふれた) オブジェクト記述子であることに注意してください!
この関数は AutoCommit が有効な場合は使用することはできません。

=item lo_write

  $nbytes = $dbh->pg_lo_write($lobj_fd, $buffer, $len);

=begin original

Writes C<$len> bytes of c<$buffer> into the large object C<$lobj_fd>.
Returns the number of bytes written and C<undef> upon failure.
This function cannot be used if AutoCommit is enabled.

=end original

ラージオブジェクト C<$lobj_fd> に C<$buffer> の内容を C<$len> バイト書き込みます。
書き込まれたバイト数が返されます。失敗した場合は C<undef> が返されます。
この関数は AutoCommit が有効な場合は使用することはできません。

=item lo_read

  $nbytes = $dbh->pg_lo_read($lobj_fd, $buffer, $len);

=begin original

Reads C<$len> bytes into c<$buffer> from large object C<$lobj_fd>. Returns the number of
bytes read and C<undef> upon failure. This function cannot be used if AutoCommit is enabled.

=end original

ラージオブジェクト C<$lobj_fd> から C<$len> バイトを C<$buffer> に読み込みます。
読み込んだバイト数が返されます。失敗した場合は、C<undef> が返されます。
この関数は AutoCommit が有効な場合は使用することはできません。

=item lo_lseek

  $loc = $dbh->pg_lo_lseek($lobj_fd, $offset, $whence);

=begin original

Changes the current read or write location on the large object
C<$obj_id>. Currently C<$whence> can only be 0 (which is L_SET). Returns the current
location and C<undef> upon failure. This function cannot be used if AutoCommit is enabled.

=end original

ラージオブジェクト C<$lobj_fd> の現在の読み書きの位置を変更します。
いまのところ、C<$whence> は 0 (L_SET) だけが指定できます。
現在の読み書きの位置が返されます。失敗した場合は C<undef> が返されます。
この関数は AutoCommit が有効な場合は使用することはできません。

=item lo_tell

  $loc = $dbh->pg_lo_tell($lobj_fd);

=begin original

Returns the current read or write location on the large object C<$lobj_fd>
and C<undef> upon failure.
This function cannot be used if AutoCommit is enabled.

=end original

ラージオブジェクト C<$lobj_fd> の現在の読み書きの位置を返します。
失敗した場合は C<undef> が返されます。
この関数は AutoCommit が有効な場合は使用することはできません。

=item lo_close

  $lobj_fd = $dbh->pg_lo_close($lobj_fd);

=begin original

Closes an existing large object. Returns true upon success and false upon failure.
This function cannot be used if AutoCommit is enabled.

=end original

既存のラージオブジェクトをクローズします。
成功時には真が、失敗時には偽が返されます。
この関数は AutoCommit が有効な場合は使用することはできません。

=item lo_unlink

  $ret = $dbh->pg_lo_unlink($lobjId);

=begin original

Deletes an existing large object. Returns true upon success and false upon failure.
This function cannot be used if AutoCommit is enabled.

=end original

存在するラージオブジェクトを削除します。
成功時には真が、失敗時には偽が返されます。
この関数は AutoCommit が有効な場合は使用することはできません。

=item lo_import

  $lobjId = $dbh->pg_lo_import($filename);

=begin original

Imports a Unix file as a large object and returns the object id of the new
object or C<undef> upon failure.

=end original

Unix のファイルをラージオブジェクトとしてインポートし、新しいオブジェクトの
object-id を返します。失敗時には C<undef> が返されます。

=item lo_import_with_oid

  $lobjId = $dbh->pg_lo_import($filename, $OID);

=begin original

Same as lo_import, but attempts to use the supplied OID as the 
large object number. If this number is 0, it falls back to the 
behavior of lo_import (which assigns the next available OID).

This is only available when DBD::Pg is compiled against a Postgres 
server version 8.4 or later.

=end original

lo_import と同様ですが、指定された OID を object-id として使うように試みます。
指定された数値が 0 の場合は、lo_import と同じ振る舞いに fall back します。
(object-id として、空いている番号を割り当てます。)

この機能は、DBD::Pg が Postgres server version 8.4
以降に対してコンパイルされた場合のみ、有効です。

=item lo_export

  $ret = $dbh->pg_lo_export($lobjId, $filename);

=begin original

Exports a large object into a Unix file. Returns false upon failure, true otherwise.

=end original

ラージオブジェクトを Unix のファイルにエクスポートします。
失敗時には偽を返し、そうでなければ真を返します。

=item getfd

  $fd = $dbh->func('getfd');

=begin original

Deprecated, use L<< $dbh->{pg_socket}|/pg_socket >> instead.

=end original

Deprecated です。代わりに L<< $dbh->{pg_socket}|/pg_socket >> を使用してください。

=back

=head3 B<private_attribute_info>

  $hashref = $dbh->private_attribute_info();
  $hashref = $sth->private_attribute_info();

=begin original

Returns a hash of all private attributes used by DBD::Pg, for either 
a database or a statement handle. Currently, all the hash values are undef.

=end original

データベースハンドル、ステートメントハンドルそれぞれについて、
DBD::Pg によって使用される全てのプライベートな属性のハッシュを返します。
いまのところ、全てのハッシュの value は undef です。

=head1 ATTRIBUTES COMMON TO ALL HANDLES

(全てのハンドルに共通の属性)

=head3 B<InactiveDestroy> (boolean)

=begin original

If set to true, then the L</disconnect> method will not be automatically called when 
the database handle goes out of scope. This is required if you are forking, and even 
then you must tread carefully and ensure that either the parent or the child (but not 
both!) handles all database calls from that point forwards, so that messages from the 
Postgres backend are only handled by one of the processes. If you don't set things up 
properly, you will see messages such as "I<server closed the connection unexpectedly>", 
and "I<message type 0x32 arrived from server while idle>". The best solution is to either 
have the child process reconnect to the database with a fresh database handle, or to 
rewrite your application not to use use forking. See the section on L</Asynchronous Queries> 
for a way to have your script continue to work while the database is processing a request.

=end original

真に設定すると、データベースハンドルがスコープから外れたときでも
L</disconnect> メソッドが自動的に呼ばれなくなります。
これは、あなたが fork を使っている際には必要となります。
この場合は、慎重になって、親プロセスか子プロセスの(両方ではなく！)どちらか一方が、
データベースとのやりとり全てを取り扱うことが確実となるようにしなければなりません。
そのため、Postgresバックエンドからのメッセージはいくつかのプロセスのうち、
ただひとつのプロセスによって扱われることになります。
もし、この点を適切に行わなかった時には、
"I<server closed the connection unexpectedly>" や
"I<message type 0x32 arrived from server while idle>"
といったメッセージを目にすることになるでしょう。
よい解決法は、子プロセスにフレッシュなデータベースハンドルで再接続させるか、
あるいは、あなたのアプリケーションが fork を使わないように書き直すことです。
データベースがリクエストを処理している最中にも、
あなたのスクリプトが処理を続けられるようにする方法については、
L</Asynchronous Queries> セクションを見てください。

(訳注: tread carefully は treat carefully か？)

=head3 B<RaiseError> (boolean, inherited)

=begin original

Forces errors to always raise an exception.
Although it defaults to off, it is recommended that this be turned on,
as the alternative is to check the return value of every method (prepare, execute, fetch, etc.) 
manually, which is easy to forget to do.

=end original

エラーの際に、常に例外を発生させるようにします。
デフォルトでは無効ですが、これを有効にすることが奨励されます。
この属性を有効にする代わりに、全てのメソッド (prepare, execute, fetch, etc.)
の戻り値を手動でチェックする方法もありますが、それをするのをよく忘れてしまうものです。

=head3 B<PrintError> (boolean, inherited)

=begin original

Forces database errors to also generate warnings,
which can then be filtered with methods such as locally redefining I<$SIG{__WARN__}>
or using modules such as C<CGI::Carp>.
This attribute is on by default.

=end original

エラーの際に warning を生成させるようにします。warning は、I<$SIG{__WARN__}>
をローカルで再定義したり、C<CGI::Carp>
といったモジュールを使用することでフィルタすることができます。
この属性はデフォルトで有効です。

=head3 B<ShowErrorStatement> (boolean, inherited)

=begin original

Appends information about the current statement to error messages. If placeholder information 
is available, adds that as well. Defaults to false.

=end original

エラーメッセージに、現在のステートメントの情報を追加します。
プレースホルダの情報があれば、それも追加されます。
デフォルトでは無効です。

=head3 B<Warn> (boolean, inherited)

=begin original

Enables warnings. This is on by default, and should only be turned off in a local block 
for a short a time only when absolutely needed.

=end original

warning を出すようにします。デフォルトで有効です。
ローカルのブロックで無効にする場合は、短い間、どうしても必要な場合にだけそうするべきです。

=head3 B<Executed> (boolean, read-only)

=begin original

Indicates if a handle has been executed.
For database handles, this value is true after the L</do> method has been called,
or when one of the child statement handles has issued an L</execute>.
Issuing a L</commit> or L</rollback> always resets the attribute to false for database handles.
For statement handles, any call to L</execute> or its variants will flip the value to 
true for the lifetime of the statement handle.

=end original

ハンドルが execute されたかどうかを示します。
データベースハンドルでは、L</do> メソッドが呼ばれた場合と、
子ステートメントハンドルのいずれかで L</execute> が発行されたときにこの値が真になります。
L</commit> と L</rollback> の発行は、常にこの属性の値を偽にリセットします。
ステートメントハンドルでは、L</execute> とその変種のどれが呼ばれても、値を真に変え、
ステートメントハンドルの生存期間のあいだそのままです。

=head3 B<TraceLevel> (integer, inherited)

=begin original

Sets the trace level, similar to the L</trace> method. See the sections on 
L</trace> and L</parse_trace_flag> for more details.

=end original

L</trace>メソッドと同様にトレースレベルを設定します。
より詳しい情報は、L</trace> と L</parse_trace_flag> のセクションにあります。

=head3 B<Active> (boolean, read-only)

=begin original

Indicates if a handle is active or not.
For database handles, this indicates if the database has been disconnected or not.
For statement handles, it indicates if all the data has been fetched yet or not.
Use of this attribute is not encouraged.

=end original

ハンドルがアクティブかどうかを示します。
データベースハンドルでは、disconnect されているかどうかを示します。
ステートメントハンドルでは、全てのデータが fetch されたかどうかを示します。
この属性の使用は奨励されません。(訳注: 代わりに XXX を...)

=head3 B<Kids> (integer, read-only)

=begin original

Returns the number of child processes created for each handle type.
For a driver handle, indicates the number of database handles created.
For a database handle, indicates the number of statement handles created.
For statement handles, it always returns zero, because statement handles do not create kids.

=end original

それぞれのハンドルの、生成された子プロセスの数を返します。
ドライバハンドルでは、生成されたデータベースハンドルの数を示します。
データベースハンドルでは、生成されたステートメントハンドルの数を示します。
ステートメントハンドルでは、常にゼロを返します。
なぜなら、ステートメントハンドルは子を作らないからです。

=head3 B<ActiveKids> (integer, read-only)

=begin original

Same as C<Kids>, but only returns those that are active.

=end original

C<Kids> と同様ですが、アクティブな子の数だけを返します。

=head3 B<CachedKids> (hash ref)

=begin original

Returns a hashref of handles.
If called on a database handle,
returns all statement handles created by use of the C<prepare_cached> method.
If called on a driver handle,
returns all database handles created by the L</connect_cached> method.

=end original

ハンドルのハッシュリファレンスを返します。
データベースハンドルについて呼ばれたときは、
C<prepare_cached> メソッドを使って生成されたステートメントハンドル全てを返します。
ドライバハンドルについて呼ばれたときは、
L</connect_cached> メソッドによって生成されたデータベースハンドル全てを返します。

=head3 B<ChildHandles> (array ref)

=begin original

Implemented by DBI, no driver-specific impact.

=end original

DBI によって実装されており、ドライバ特有の影響はありません。

=head3 B<PrintWarn> (boolean, inherited)

=begin original

Implemented by DBI, no driver-specific impact.

=end original

DBI によって実装されており、ドライバ特有の影響はありません。

=head3 B<HandleError> (boolean, inherited)

=begin original

Implemented by DBI, no driver-specific impact.

=end original

DBI によって実装されており、ドライバ特有の影響はありません。

=head3 B<HandleSetErr> (code ref, inherited)

=begin original

Implemented by DBI, no driver-specific impact.

=end original

DBI によって実装されており、ドライバ特有の影響はありません。

=head3 B<ErrCount> (unsigned integer)

=begin original

Implemented by DBI, no driver-specific impact.

=end original

DBI によって実装されており、ドライバ特有の影響はありません。

=head3 B<FetchHashKeyName> (string, inherited)

=begin original

Implemented by DBI, no driver-specific impact.

=end original

DBI によって実装されており、ドライバ特有の影響はありません。

=head3 B<ChopBlanks> (boolean, inherited)

=begin original

Supported by DBD::Pg as proposed by DBI. This method is similar to the
SQL function C<RTRIM>.

=end original

DBI の提案により DBD::Pg によってサポートされています。
このメソッドは SQL 関数 C<RTRIM> と同じです。

=head3 B<Taint> (boolean, inherited)

=begin original

Implemented by DBI, no driver-specific impact.

=end original

DBI によって実装されており、ドライバ特有の影響はありません。

=head3 B<TaintIn> (boolean, inherited)

=begin original

Implemented by DBI, no driver-specific impact.

=end original

DBI によって実装されており、ドライバ特有の影響はありません。

=head3 B<TaintOut> (boolean, inherited)

=begin original

Implemented by DBI, no driver-specific impact.

=end original

DBI によって実装されており、ドライバ特有の影響はありません。

=head3 B<Profile> (inherited)

=begin original

Implemented by DBI, no driver-specific impact.

=end original

DBI によって実装されており、ドライバ特有の影響はありません。

=head3 B<Type> (scalar)

=begin original

Returns C<dr> for a driver handle,
C<db> for a database handle, and C<st> for a statement handle. 
Should be rarely needed.

=end original

ドライバハンドルでは C<dr> が、
データベースハンドルでは C<db> が、
ステートメントハンドルでは C<st> が返されます。
めったに必要となることはないでしょう。

=head3 B<LongReadLen>

=begin original

Not used by DBD::Pg

=end original

DBD::Pg では使用されません。

=head3 B<LongTruncOk>

=begin original

Not used by DBD::Pg

=end original

DBD::Pg では使用されません。

=head3 B<CompatMode>

=begin original

Not used by DBD::Pg

=end original

DBD::Pg では使用されません。

=head1 DBI DATABASE HANDLE OBJECTS

=head2 Database Handle Methods

=head3 B<selectall_arrayref>

  $ary_ref = $dbh->selectall_arrayref($sql);
  $ary_ref = $dbh->selectall_arrayref($sql, \%attr);
  $ary_ref = $dbh->selectall_arrayref($sql, \%attr, @bind_values);

=begin original

Returns a reference to an array containing the rows returned
by preparing and executing the SQL string.
See the DBI documentation for full details. 

=end original

指定された SQL 文字列を prepare し、execute した結果の行を含む配列へのリファレンスを返します。
詳細は、DBI のドキュメントを見てください。

=head3 B<selectall_hashref>

  $hash_ref = $dbh->selectall_hashref($sql, $key_field);

=begin original

Returns a reference to a hash containing the rows returned
by preparing and executing the SQL string.
See the DBI documentation for full details. 

=end original

指定された SQL 文字列を prepare し、execute した結果の行を含むハッシュへのリファレンスを返します。
詳細は、DBI のドキュメントを見てください。

=head3 B<selectcol_arrayref>

  $ary_ref = $dbh->selectcol_arrayref($sql, \%attr, @bind_values);

=begin original

Returns a reference to an array containing the first column from each rows
returned by preparing and executing the SQL string. It is possible to specify exactly 
which columns to return. See the DBI documentation for full details. 

=end original

指定された SQL 文字列を prepare し、execute した結果の行それぞれの、
最初のカラムを含む配列へのリファレンスを返します。
どのカラムを返すかを厳密に指定することも可能です。
詳細は、DBI のドキュメントを見てください。

=head3 B<prepare>

  $sth = $dbh->prepare($statement, \%attr);

=begin original

WARNING: DBD::Pg now (as of version 1.40) uses true prepared statements by sending them 
to the backend to be prepared by the Postgres server. Statements 
that were legal before may no longer work. See below for details.

=end original

警告: DBD::Pg は現在では (version 1.40 現在) 本物の準備された文を使用します。
かつて有効だった文は、もう動かないかもしれません。
詳細は、下記を見てください。

=begin original

The prepare method prepares a statement for later execution. PostgreSQL supports 
prepared statements, which enables DBD::Pg to only send the query once, and
simply send the arguments for every subsequent call to L</execute>.
DBD::Pg can use these server-side prepared statements, or it can
just send the entire query to the server each time. The best way
is automatically chosen for each query. This will be sufficient for
most users: keep reading for a more detailed explanation and some
optional flags.

=end original

prepare メソッドは、後の実行に備えて準備された文を作成します。
PostgreSQL は準備された文をサポートしているので、DBD::Pg は一度だけクエリを送り、
そのあとに呼ばれる全ての L</execute> では、引数を送るだけで済むようになります。
DBD::Pg はサーバサイドに作成しておいた準備された文を使うこともできますし、
クエリの全体を毎回サーバに送るようにすることもできます。
最善の方法は、それぞれのクエリによって自動的に選択されます。
これは、ほとんどのユーザにとって十分でしょう。
以下には、より詳細な説明と、いくつかのオプショナルなフラグについての説明があります。

=begin original

Queries that do not begin with the word "SELECT", "INSERT", 
"UPDATE", or "DELETE" are never sent as server-side prepared statements.

=end original

クエリの最初の語が、"SELECT", "INSERT", "UPDATE", "DELETE" のいずれでもない場合は、
サーバサイドに準備された文を作成しようとしません。

(訳注: WITH はだめなのか？)

=begin original

Deciding whether or not to use prepared statements depends on many factors, 
but you can force them to be used or not used by using the 
L</pg_server_prepare> attribute when calling L</prepare>. Setting this to "0" means to never use 
prepared statements. Setting L</pg_server_prepare> to "1" means that prepared 
statements should be used whenever possible. This is the default when connected 
to Postgres servers version 8.0 or higher. Servers that are version 7.4 get a special 
default value of "2", because server-side statements were only partially supported 
in that version. In this case, it only uses server-side prepares if all 
parameters are specifically bound.

=end original

準備された文を使うかどうかの決定は、たくさんの要因によりますが、
L</prepare> を呼ぶ際に、属性 L</pg_server_prepare> を使うことで、
準備された文を使わせるかどうかを強制させることができます。
"0" に設定すると、準備された文を使わないという意味になり、
L</pg_server_prepare> を "1" に設定すると、可能であれば常に使うという意味になります。
これは、Postgres サーバの version 8.0 以上に接続しているときのデフォルトです。
version 7.4 のサーバに対しては、特別なデフォルト値 "2" があります。
このバージョンではサーバサイドの文が部分的にしかサポートされていない為です。
この場合、全てのパラメータの値が指定されたときにだけサーバサイドの準備された文が使用されます。

(訳注: 全てのパラメータが指定されない場合ってあるっけ？)

=begin original

The L</pg_server_prepare> attribute can also be set at connection time like so:

=end original

L</pg_server_prepare> 属性は、接続時に設定することもできます:

  $dbh = DBI->connect($DBNAME, $DBUSER, $DBPASS,
                      { AutoCommit => 0,
                        RaiseError => 1,
                        pg_server_prepare => 0,
                      });

=begin original

or you may set it after your database handle is created:

=end original

または、データベースハンドルが生成された後で指定することもできます:

  $dbh->{pg_server_prepare} = 1;

=begin original

To enable it for just one particular statement:

=end original

ある特定のステートメントでのみ、有効化するには:

  $sth = $dbh->prepare("SELECT id FROM mytable WHERE val = ?",
                       { pg_server_prepare => 1 });

=begin original

You can even toggle between the two as you go:

=end original

あなたの言うがままに、有効と無効を行ったり来たり:

  $sth->{pg_server_prepare} = 1;
  $sth->execute(22);
  $sth->{pg_server_prepare} = 0;
  $sth->execute(44);
  $sth->{pg_server_prepare} = 1;
  $sth->execute(66);

=begin original

In the above example, the first execute will use the previously prepared statement.
The second execute will not, but will build the query into a single string and send
it to the server. The third one will act like the first and only send the arguments.
Even if you toggle back and forth, a statement is only prepared once.

=end original

上の例の最初の execute は、それ以前の prepare 呼び出しで生成しておいた準備された文を使用します。
2つ目の execute では使用せず、クエリをひとつの文字列として組み立ててサーバに送ります。
3つ目では最初と同じように引数だけを送ります。
たとえ何度も有効無効の切り替えを繰り返しても、文が PREPARE されるのは一度だけです。

=begin original

Using prepared statements is in theory quite a bit faster: not only does the
PostgreSQL backend only have to prepare the query only once, but DBD::Pg no
longer has to worry about quoting each value before sending it to the server.

=end original

プリペアド文を使うのは PostgreSQL バックエンドに対してクエリをただ一度送るだけで済むので、
かなり速くなる、というのが理由ですが、それだけではなく、サーバにクエリを送る前に
DBD::Pg 側でそれぞれの値をクォートするという面倒を見なくて済むという理由もあります。

(訳注: XXX)

=begin original

However, there are some drawbacks. The server cannot always choose the ideal
parse plan because it will not know the arguments before hand. But for most
situations in which you will be executing similar data many times, the default
plan will probably work out well. Programs such as PgBouncer which cache connections 
at a low level should not use prepared statements via DBD::Pg, or must take 
extra care in the application to account for the fact that prepared statements 
are not shared across database connections. Further discussion on this subject is beyond
the scope of this documentation: please consult the pgsql-performance mailing
list, L<http://archives.postgresql.org/pgsql-performance/>

=end original

しかしながら、ここにはいくつかの欠点もあります。
サーバは実際のパラメータの値をあらかじめ知ることができないので、
常に理想的な実行計画を選択できるわけではありません。
しかし、あなたが同類の問い合わせを何度も実行している、といった状況のほとんどにおいて、
デフォルトの計画でうまくいくでしょう。
PgBouncer のような低レベルでコネクションをキャッシュするプログラムでは
DBD::Pg 経由で準備された文を使わないようにするか、あるいは
準備された文は複数のデータベース接続を超えて共有されないことを考慮するよう、
アプリケーション内で特別な注意を払わなければいけません。
この件に関するこれ以上の議論は、このドキュメントの範囲を超えますので、
pgsql-performance メーリングリスト L<http://archives.postgresql.org/pgsql-performance/>
をご覧ください。

(訳注: parse plan:解析計画？ 実行計画とした。)

=begin original

Only certain commands will be sent to a server-side prepare: currently these
include C<SELECT>, C<INSERT>, C<UPDATE>, and C<DELETE>. DBD::Pg uses a simple
naming scheme for the prepared statements themselves: B<dbdpg_XY_Z>, where B<Y> is the current 
PID, B<X> is either 'p' or 'n' (depending on if the PID is a positive or negative 
number), and B<Z> is a number that starts at 1 and increases each time a new statement 
is prepared. This number is tracked at the database handle level, so multiple
statement handles will not collide.

=end original

ある決まったコマンドだけがサーバサイドの prepare に送られます: いまのところ、それらは
C<SELECT>, C<INSERT>, C<UPDATE>, そして C<DELETE> を(訳注: 文の頭に)含む文です。
DBD::Pg は、ある単純な規則でプリペアド文に名前をつけます:
それは、B<dbdpg_XY_Z> というもので B<Y> の部分には現在の PID 、
B<X> は、'p' か 'n' のどちらか( PID が正の数か負の数かによる)、そして
B<Z> は 1 から始まって新しい文を準備するたびに増えていく数です。
この数値は、データベースハンドルレベルで追跡されているので、
複数のステートメントハンドルで衝突することはありません。

=begin original

You cannot send more than one command at a time in the same prepare command 
(by separating them with semi-colons) when using server-side prepares.

=end original

サーバサイドのプリペアド文を使用している時には、1つの prepare コマンドの中に
(セミコロンで区切って) 複数の SQL コマンドを入れることはできません。

=begin original

The actual C<PREPARE> is usually not performed until the first execute is called, due
to the fact that information on the data types (provided by L</bind_param>) may
be provided after the prepare but before the execute.

=end original

The actual C<PREPARE> is usually not performed until the first execute is called, due
to the fact that information on the data types (provided by L</bind_param>) may
be provided after the prepare but before the execute.

実際の C<PREPARE> 文は普通、
最初の execute が呼ばれるまで実行されません。
これは、データ型についての情報が execute をするときまでに( L</bind_param> によって)
与えられるというのが理由です。

(訳注: XXX)

=begin original

A server-side prepare may happen before the first L</execute>, but only if the server can
handle the server-side prepare, and the statement contains no placeholders. It will 
also be prepared if the L</pg_prepare_now> attribute is passed in and set to a true 
value. Similarly, the L</pg_prepare_now> attribute can be set to 0 to ensure that
the statement is B<not> prepared immediately, although the cases in which you would
want this are very rare. Finally, you can set the default behavior of all prepare
statements by setting the L</pg_prepare_now> attribute on the database handle:

=end original

サーバが、サーバサイドのプリペアド文を扱えて、かつ、文の中にプレースホルダが無い場合を除き、
実際の C<PREPARE> 文は最初の L</execute> の呼び出しの前に発行されます。
また、C<prepare> メソッドの呼び出しの際に L</pg_prepare_now>
属性が真の値とともに渡された場合も、実際の C<PREPARE> 文がすぐに発行されます。
逆に、(こういうことをしたくなるケースは非常にまれだと思いますが) L</pg_prepare_now>
属性に偽の値をセットして渡すと、ただちに C<PREPARE> を発行B<しない>ようになります。
最後に、全ての prepare メソッドのデフォルトの振る舞いを変更するために、
データベースハンドルの L</pg_prepare_now> 属性を変更することができます:

  $dbh->{pg_prepare_now} = 1;

=begin original

The following two examples will be prepared right away:

=end original

次の2つの例では、ただちに prepare が行われます:

  $sth->prepare("SELECT 123"); ## no placeholders

  $sth->prepare("SELECT 123, ?", {pg_prepare_now => 1});

=begin original

The following two examples will NOT be prepared right away:

=end original

次の2つの例では、prepare はすぐには行われません:

  $sth->prepare("SELECT 123, ?"); ## has a placeholder

  $sth->prepare("SELECT 123", {pg_prepare_now => 0});

=begin original

There are times when you may want to prepare a statement yourself. To do this,
simply send the C<PREPARE> statement directly to the server (e.g. with
the L</do> method). Create a statement handle and set the prepared name via
the L</pg_prepare_name> attribute. The statement handle can be created with a dummy
statement, as it will not be executed. However, it should have the same
number of placeholders as your prepared statement. Example:

=end original

あなた自身が PREPARE 文を使いたくなることがあるかも知れません。
それをするには、単純に C<PREPARE> 文を(L</do> メソッドなどを使って)直接サーバに送り、
ステートメントハンドルを作成し、L</pg_prepare_name> 属性にプリペアド文の名前をセットしてください。
ステートメントハンドルはダミーの SQL 文を与えることで作成できますが、あなたが準備したい SQL 文と
同数のプレースホルダを含んでいなければなりません。
例を示します:

  $dbh->do('PREPARE mystat AS SELECT COUNT(*) FROM pg_class WHERE reltuples < ?');
  $sth = $dbh->prepare('SELECT ?');
  $sth->bind_param(1, 1, SQL_INTEGER);
  $sth->{pg_prepare_name} = 'mystat';
  $sth->execute(123);

=begin original

The above will run the equivalent of this query on the backend:

=end original

上の例は、次のクエリがバックエンドで実行されることと等価です:

  EXECUTE mystat(123);

=begin original

which is the equivalent of:

=end original

そしてそれは、次とも等価です:

  SELECT COUNT(*) FROM pg_class WHERE reltuples < 123;

=begin original

You can force DBD::Pg to send your query directly to the server by adding
the L</pg_direct> attribute to your prepare call. This is not recommended,
but is added just in case you need it.

=end original

DBD::Pg に対して、あなたのクエリを直接サーバに送るように強制させるには、
L</pg_direct> 属性を prepare 呼び出しに追加してください。
これは奨励はされませんが、あなたが必要とする場合に備えて使えるようにしてあります。

=head4 B<Placeholders>

=begin original

There are three types of placeholders that can be used in DBD::Pg. The first is
the "question mark" type, in which each placeholder is represented by a single
question mark character. This is the method recommended by the DBI specs and is the most
portable. Each question mark is internally replaced by a "dollar sign number" in the order
in which they appear in the query (important when using L</bind_param>).

=end original

DBD::Pg で使用できるプレースホルダには3つのタイプがあります。
1つめは、それぞれのプレースホルダが一文字のクエスチョンマークで表される
"question mark" タイプです。
これは、DBI specによって推奨されている方法であり、もっともポータビリティがあります。
それぞれのクエスチョンマークは、内部でクエリ中に出現する順序で
"dollar sign number"(ドルマーク 番号)に置き換えられます。

=begin original

The method second type of placeholder is "dollar sign numbers". This is the method
that Postgres uses internally and is overall probably the best method to use
if you do not need compatibility with other database systems. DBD::Pg, like
PostgreSQL, allows the same number to be used more than once in the query.
Numbers must start with "1" and increment by one value (but can appear in any order 
within the query). If the same number appears more than once in a query, it is treated as a 
single parameter and all instances are replaced at once. Examples:

=end original

2つ目のプレースホルダのタイプは "dollar sign numbers" です。このタイプは、Postgres
が内部的に使っている方法であり、ほかのデータベースシステムとの互換性を必要としないのであれば、
全体のなかでおそらくいちばん良いものです。
DBD::Pg は PostgreSQL と同様に、1つのクエリの中で同じ番号を複数回使うことを許しています。
番号は、かならず "1" から始めなければならず、1つの値につき 1 ずつ増やしていかなければなりません。
(ただし、クエリの中でどのような順番で出現しても良いです)
クエリの中で同じ番号が2回以上現れたときは、それは1つのパラメータとして扱われ、
どれも同じ値に書き換えられます。例を示します:

=begin original

Not legal:

  $SQL = 'SELECT count(*) FROM pg_class WHERE relpages > $2'; # Does not start with 1

  $SQL = 'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $1 AND $3'; # Missing 2

Legal:

  $SQL = 'SELECT count(*) FROM pg_class WHERE relpages > $1';

  $SQL = 'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $1 AND $2';

  $SQL = 'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $2 AND $1'; # legal but confusing

  $SQL = 'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $1 AND $2 AND reltuples > $1';

  $SQL = 'SELECT count(*) FROM pg_class WHERE relpages > $1 AND reltuples > $1';

=end original

違法:

  $SQL = 'SELECT count(*) FROM pg_class WHERE relpages > $2'; # 1 から始めていない

  $SQL = 'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $1 AND $3'; # 2 がない

合法:

  $SQL = 'SELECT count(*) FROM pg_class WHERE relpages > $1';

  $SQL = 'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $1 AND $2';

  $SQL = 'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $2 AND $1'; # 合法だが紛らわしい

  $SQL = 'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $1 AND $2 AND reltuples > $1';

  $SQL = 'SELECT count(*) FROM pg_class WHERE relpages > $1 AND reltuples > $1';

=begin original

In the final statement above, DBI thinks there is only one placeholder, so this
statement will replace both placeholders:

=end original

上の例の最後の文は、DBI はただ1つのプレースホルダがあると考えますので、
次の文は両方のプレースホルダを 2045 に置き換えます:

  $sth->bind_param(1, 2045);

=begin original

While a simple execute with no bind_param calls requires only a single argument as well:

=end original

一方、bind_param の呼び出しをせずにシンプルに実行することもできます。必要となるのは
引数1つだけです:

  $sth->execute(2045);

=begin original

The final placeholder type is "named parameters" in the format ":foo". While this
syntax is supported by DBD::Pg, its use is discouraged in favor of 
dollar-sign numbers.

=end original

最後のプレースホルダのタイプは ":foo" という形式の "named parameters" です。
この文法は DBD::Pg によってサポートされてはいますが、使うことはお勧めしません。
代わりに "dollar sign numbers" を使うことをお勧めします。

=begin original

The different types of placeholders cannot be mixed within a statement, but you may
use different ones for each statement handle you have. This is confusing at best, so 
stick to one style within your program.

=end original

異なった種類のプレースホルダを1つの文の中で混ぜて使うことはできませんが、
複数のステートメントハンドルに対して、それぞれ別な種類のプレースホルダを使うことはできます。
しかしこれは、せいぜい混乱を招くだけでしょうから、
あなたが書くプログラムの中では一種類のやりかたを貫きましょう。

=begin original

If your queries use operators that contain question marks (e.g. some of the native 
Postgres geometric operators) or array slices (e.g. C<data[100:300]>), you can tell 
DBD::Pg to ignore any non-dollar sign placeholders by setting the 
L</pg_placeholder_dollaronly> attribute at either the database handle or the statement 
handle level. Examples:

=end original

もし、クエリの中でクエスチョンマークを含む演算子
(例: Postgres の幾何データ演算子のうちのいくつか)や部分配列式(例: C<data[100:300]>)
を使っている場合は、データベースハンドルかステートメントハンドルの
L</pg_placeholder_dollaronly> 属性を設定することによって、DBD::Pg に対して
"dollar sign numbers" 以外のプレースホルダを無視するように伝えることができます。
例:

  $dbh->{pg_placeholder_dollaronly} = 1;
  $sth = $dbh->prepare(q{SELECT * FROM mytable WHERE lseg1 ?# lseg2 AND name = $1});
  $sth->execute('segname');

=begin original

Alternatively, you can set it at prepare time:

=end original

あるいは prepare するときに設定することもできます:

  $sth = $dbh->prepare(q{SELECT * FROM mytable WHERE lseg1 ?-| lseg2 AND name = $1},
    {pg_placeholder_dollaronly = 1});
  $sth->execute('segname');

=head3 B<prepare_cached>

  $sth = $dbh->prepare_cached($statement, \%attr);

=begin original

Implemented by DBI, no driver-specific impact. This method is most useful
when using a server that supports server-side prepares, and you have asked
the prepare to happen immediately via the L</pg_prepare_now> attribute.

=end original

DBI によって実装されており、ドライバ特有の影響はありません。
サーバが準備された文をサポートしており、かつ、あなたが L</pg_prepare_now>
属性を設定して prepare が即座に行われるようにしている場合には、このメソッドは非常に有用です。

=head3 B<do>

  $rv = $dbh->do($statement);
  $rv = $dbh->do($statement, \%attr);
  $rv = $dbh->do($statement, \%attr, @bind_values);

=begin original

Prepare and execute a single statement. Returns the number of rows affected if the 
query was successful, returns undef if an error occurred, and returns -1 if the 
number of rows is unknown or not available. Note that this method will return B<0E0> instead
of 0 for 'no rows were affected', in order to always return a true value if no error occurred.

=end original

1つの文を prepare して execute します。クエリが成功した場合には、その行数を返し、
エラーの場合は undef を、行数がわからないか、available でない場合は -1 を返します。
このメソッドは '該当する行が無かった' ことを示すために 0 ではなく
B<0E0> を返すことに注意してください。
これは、エラーが起こっていない場合には、常に真となる値を返すようにするためです。

=begin original

If neither C<\%attr> nor C<@bind_values> is given, the query will be sent directly
to the server without the overhead of internally creating a statement handle and
running prepare and execute, for a measurable speed increase.

=end original

C<\%attr> も C<@bind_values> も与えられない場合は、内部でステートメントハンドルを作成したり
prepare してから execute したりする手間をかけずに、クエリを直接サーバに送ります。
これである程度速度が向上します。

=begin original

Note that an empty statement (a string with no length) will not be passed to
the server; if you want a simple test, use "SELECT 123" or the L</ping> method.

=end original

空の文(長さがゼロの文字列)を与えたときは、サーバには何も送られないことに注意してください。
もし、シンプルなテストをしたいのであれば、"SELECT 123"
といった文を使うか、あるいは L</ping> メソッドを使用してください。

=head3 B<last_insert_id>

  $rv = $dbh->last_insert_id(undef, $schema, $table, undef);
  $rv = $dbh->last_insert_id(undef, $schema, $table, undef, {sequence => $seqname});

=begin original

Attempts to return the id of the last value to be inserted into a table.
You can either provide a sequence name (preferred) or provide a table
name with optional schema, and DBD::Pg will attempt to find the sequence itself. 
The current value of the sequence is returned by a call to the C<CURRVAL()> 
PostgreSQL function. This will fail if the sequence has not yet been used in the 
current database connection.

=end original

テーブルに対し、最後に INSERT された id の値を返そうと試みます。
このメソッドに、シーケンス名かを与えることができます。
与えられなければ、テーブル名を(省略可能なスキーマ名とともに)与えることができ
DBD::Pg はシーケンス自体を探すことを試みます。
現在のシーケンスの値は、PostgreSQL の関数 C<CURRVAL()> によって返されます。
この関数の呼び出しは、現在のデータベース接続の中で、
そのシーケンスがまだ一度も使われていないときには失敗します。

=begin original

If you do not know the name of the sequence, you can provide a table name and
DBD::Pg will attempt to return the correct value. To do this, there must be at
least one column in the table with a C<NOT NULL> constraint, that has a unique
constraint, and which uses a sequence as a default value. If more than one column
meets these conditions, the primary key will be used. This involves some
looking up of things in the system table, so DBD::Pg will cache the sequence
name for subsequent calls. If you need to disable this caching for some reason,
(such as the sequence name changing), you can control it by adding C<< pg_cache => 0 >>
to the final (hashref) argument for last_insert_id.

=end original

あなたがシーケンス名を知らない場合でも、テーブル名を与えれば
DBD::Pg は正しい値を返そうと試みます。
これを行うために、C<NOT NULL> 制約と一意性制約 (C<UNIQUE>) を持っており、かつ、
シーケンスをデフォルト値として使っているカラムが、
そのテーブルに少なくとも1つは存在していないといけません。
もし、2つ以上のカラムが、この条件にマッチした場合は、プライマリキーが使われます。
DBD::Pg は、その後に呼び出されたときのためにシーケンス名をキャッシュしようとするため、
システムテーブルの中を検索します。
なんらかの(シーケンス名の変更など)理由で、このキャッシングを止めたい場合には、
C<< pg_cache => 0 >> を last_insert_id メソッドの最後の引数として
(ハッシュのリファレンスで)加えることで、とめることができます。

=begin original

Please keep in mind that this method is far from foolproof, so make your
script use it properly. Specifically, make sure that it is called
immediately after the insert, and that the insert does not add a value
to the column that is using the sequence as a default value. However, because 
we are using sequences, you can be sure that the value you got back has not 
been used by any other process.

=end original

このメソッドは foolproof からは程遠いことをどうか心に留めておいてください。
なので、あなたのスクリプトを適切に書いてください。特に、このメソッド呼ぶのを
INSERT のすぐ後にすること、そして、INSERT では追加する値を書かずに、シーケンスの
デフォルト値を使って行うことを確実にしてください。
しかし、シーケンスを使っているわけですからここで得られる値はほかの処理では
使われていないことは確実です。

=begin original

Some examples:

=end original

いくつか例を示します:

  $dbh->do('CREATE SEQUENCE lii_seq START 1');
  $dbh->do(q{CREATE TABLE lii (
    foobar INTEGER NOT NULL UNIQUE DEFAULT nextval('lii_seq'),
    baz VARCHAR)});
  $SQL = 'INSERT INTO lii(baz) VALUES (?)';
  $sth = $dbh->prepare($SQL);
  for (qw(uno dos tres cuatro)) {
    $sth->execute($_);
    my $newid = $dbh->last_insert_id(undef,undef,undef,undef,{sequence=>'lii_seq'});
    print "Last insert id was $newid\n";
  }

=begin original

If you did not want to worry about the sequence name:

=end original

シーケンス名について心配したくなかったら:

  $dbh->do('CREATE TABLE lii2 (
    foobar SERIAL UNIQUE,
    baz VARCHAR)');
  $SQL = 'INSERT INTO lii2(baz) VALUES (?)';
  $sth = $dbh->prepare($SQL);
  for (qw(uno dos tres cuatro)) {
    $sth->execute($_);
    my $newid = $dbh->last_insert_id(undef,undef,"lii2",undef);
    print "Last insert id was $newid\n";
  }

=head3 B<commit>

  $rv = $dbh->commit;

=begin original

Issues a COMMIT to the server, indicating that the current transaction is finished and that 
all changes made will be visible to other processes. If AutoCommit is enabled, then 
a warning is given and no COMMIT is issued. Returns true on success, false on error.
See also the the section on L</Transactions>.

=end original

サーバに対し COMMIT を発行します。サーバに対し、現在のトランザクションが終了したことを伝えて、
全ての変更がほかのプロセスから見えるようにします。もし、AutoCommit が有効な場合には、warning
が発生し、COMMIT は発行されません。成功時には真を返し、失敗の場合にはエラーとなります。
L</Transactions> のセクションもご覧ください。

=head3 B<rollback>

  $rv = $dbh->rollback;

=begin original

Issues a ROLLBACK to the server, which discards any changes made in the current transaction.
If AutoCommit is enabled, then a warning is given and no ROLLBACK is issued.
Returns true on success, and false on error. See also the the section on L</Transactions>.

=end original

サーバに対し ROLLBACK を発行します。現在のトランザクションで行われた変更は全て破棄されます。
AutoCommit が有効な場合には warning が発生し、ROLLBACK は発行されません。
成功時には真を返し、失敗の場合にはエラーとなります。
L</Transactions> のセクションもご覧ください。

=head3 B<begin_work>

=begin original

This method turns on transactions until the next call to L</commit> or L</rollback>,
if L</AutoCommit> is currently enabled. If it is not enabled, calling begin_work will
issue an error. Note that the transaction will not actually begin until the first
statement after begin_work is called.
Example:

=end original

L</AutoCommit> が有効な場合に、次に L</commit> か L</rollback>
が呼ばれるまでのあいだのトランザクションを開始します。もし、L</AutoCommit>
が有効でないのに begin_work を呼び出すとエラーが発生します。begin_work
が呼ばれた後の最初のステートメントが呼ばれるまで、
実際のトランザクションは開始しないことに注意してください。
例:

=begin original

  $dbh->{AutoCommit} = 1;
  $dbh->do('INSERT INTO foo VALUES (123)'); ## Changes committed immediately
  $dbh->begin_work();
  ## Not in a transaction yet, but AutoCommit is set to 0

  $dbh->do("INSERT INTO foo VALUES (345)");
  ## DBD::PG actually issues two statements here:
  ## BEGIN;
  ## INSERT INTO foo VALUES (345)
  ## We are now in a transaction

  $dbh->commit();
  ## AutoCommit is now set to 1 again

=end original

  $dbh->{AutoCommit} = 1;
  $dbh->do('INSERT INTO foo VALUES (123)'); ## 変更は直ちにコミットされます
  $dbh->begin_work();
  ## まだトランザクションは開始していません。 AutoCommit は 0 にセットされます。

  $dbh->do("INSERT INTO foo VALUES (345)");
  ## ここで DBD::Pg は実際に2つの文を発行します:
  ## BEGIN;
  ## INSERT INTO foo VALUES (345)
  ## トランザクションの中にいます

  $dbh->commit();
  ## AutoCommit が、1 にセットしなおされます

=head3 B<disconnect>

  $rv = $dbh->disconnect;

=begin original

Disconnects from the Postgres database. Any uncommitted changes will be rolled back
upon disconnection. It's good policy to always explicitly call commit or rollback
at some point before disconnecting, rather than relying on the default rollback behavior.

=end original

Postgres データベースとの接続を閉ざします。コミットされていない変更はロールバックされます。
切断時にロールバックされるというデフォルトの動作を当てにするよりは、
接続を閉ざすより前のどこかの時点で明示的にコミットかロールバックを呼び出すようにするほうが
良いやりかたです。

=begin original

This method may give warnings about "disconnect invalidates X active statement handle(s)".
This means that you called C<< $sth->execute() >> but did not finish fetching all the rows
from them. To avoid seeing this warning, either fetch all the rows or call
C<< $sth->finish() >> for each executed statement handle.

=end original

このメソッドは、"disconnect invalidates X active statement handle(s)" という warning を
出すことがあります。これは、あなたが C<< $sth->execute() >> を呼んだのに、
全ての行を読み終わっていないことを意味します。この warning
を見ないようにするには、全ての行を読み出すか、C<< $sth->finish() >>
をステートメントハンドルそれぞれについて呼び出してください。

=begin original

If the script exits before disconnect is called (or, more precisely,
if the database handle is no longer referenced by anything),
then the database handle's DESTROY method will call the rollback() and disconnect() 
methods automatically. It is best to explicitly disconnect rather than rely on this behavior.

=end original

もし、disconnect が呼ばれる前にプログラムが exit した場合
(より正確には、データベースハンドルが、もうどこからも参照されていない状態になった場合)
データベースハンドルの DESTROY メソッドが自動的に rollback() と
disconnect() メソッドを呼び出します。
この振る舞いを当てにするより、明示的に disconnect を呼び出すほうが最善です。

=head3 B<quote>

  $rv = $dbh->quote($value, $data_type);

=begin original

This module implements its own C<quote> method. For simple string types, both backslashes 
and single quotes are doubled. You may also quote arrayrefs and receive a string 
suitable for passing into Postgres array columns.

=end original

このモジュールは自身で C<quote> メソッドを実装しています。単純な文字列型のために、
バックスラッシュとシングルクォートの両方を2重にします。配列のリファレンスも渡すことができ、
Postgres の配列型カラムにふさわしい文字列が返されます。

=begin original

If the value contains backslashes, and the server is version 8.1 or higher, 
then the escaped string syntax will be used (which places a capital E before 
the first single quote). This syntax is always used when quoting bytea values 
on servers 8.1 and higher.

=end original

値がバックスラッシュを含んでおり、サーバのバージョンが 8.1 かそれ以上だった場合、
エスケープ文字定数の形式(最初のシングルクォートの前に大文字の E を置く形式)が使われます。
サーバのバージョンが 8.1 かそれ以上で bytea
型の値をクォートする場合には常に、この形式が使われます。

=begin original

The C<data_type> argument is optional and should be one of the type constants 
exported by DBD::Pg (such as PG_BYTEA). In addition to string, bytea, char, bool, 
and other standard types, the following geometric types are supported: point, line, 
lseg, box, path, polygon, and circle (PG_POINT, PG_LINE, PG_LSEG, PG_BOX, 
PG_PATH, PG_POLYGON, and PG_CIRCLE respectively). To quote a Postgres-specific 
data type, you must use a 'hashref' argument like so:

=end original

C<data_type> 引数は省略可能で、指定するときは DBD::Pg によって export されている型定数
(例: PG_BYTEA) でなければなりません。string, bytea, char, bool などの標準型に加え、
次の幾何データ型がサポートされています: 座標点、直線、線分、矩形、経路、多角形、そして円。
(それぞれ PG_POINT, PG_LINE, PG_LSEG, PG_BOX, PG_PATH, PG_POLYGON, PG_CIRCLE。)
Postgres 特有のデータ型をクォートするには、引数に 'hashref' (連想配列へのリファレンス) を
用いて、次のように書かなければなりません:

  my $quotedval = $dbh->quote($value, { pg_type => PG_VARCHAR });

=begin original

B<NOTE:> The undocumented (and invalid) support for the C<SQL_BINARY> data
type is officially deprecated. Use C<PG_BYTEA> with C<bind_param()> instead:

=end original

B<NOTE:> ドキュメントされていない(かつ、正しくない) C<SQL_BINARY> 型のサポートは
公式に deprecated です。代わりに、C<PG_BYTEA> を C<bind_param()> で使ってください:

  $rv = $sth->bind_param($param_num, $bind_value,
                         { pg_type => PG_BYTEA });

=head3 B<quote_identifier>

  $string = $dbh->quote_identifier( $name );
  $string = $dbh->quote_identifier( undef, $schema, $table);

=begin original

Returns a quoted version of the supplied string, which is commonly a schema, 
table, or column name. The three argument form will return the schema and 
the table together, separated by a dot. Examples:

=end original

与えられた文字列のクォートされたものを返します。通常はスキーマ名、テーブル名、
カラム名を表す文字列です。3つの引数をとる形式では、
スキーマ名とテーブル名がドットをはさんで繋げられて返されます。例:

  print $dbh->quote_identifier('grapefruit'); ## Prints: "grapefruit"

  print $dbh->quote_identifier('juicy fruit'); ## Prints: "juicy fruit"

  print $dbh->quote_identifier(undef, 'public', 'pg_proc');
  ## Prints: "public"."pg_proc"

=head3 B<pg_notifies>

  $ret = $dbh->pg_notifies;

=begin original

Looks for any asynchronous notifications received and returns either C<undef> 
or a reference to a three-element array consisting of an event name, the PID 
of the backend that sent the NOTIFY command, and the optional payload string. 
Note that this does not check if the connection to the database is still valid first - 
for that, use the c<ping> method. You may need to commit if not in autocommit mode - 
new notices will not be picked up while in the middle of a transaction. An example:

=end original

受け取った非同期通知を探し C<undef> か、3つの要素からなる配列のリファレンスを返します。
3つの要素とは、条件通知名、NOTIFY コマンドを送ったバックエンドプロセスの
PID、そして通知パラメータです。このメソッドは、
最初にデータベースとの接続が今も有効かどうかのチェックをしません。ですから C<ping>
メソッドをつかってください。もし AutoCommit が有効になっていない場合には、このメソッド
の使用に先立って commit する必要があるかもしれません。新しく到着した通知は、
トランザクションの途中で拾い上げられることはありません。例:

(訳注: 原文の event name は「条件通知名」、payload string は「通知パラメータ」とした。
pgsql-doc-ja 「30.7. 非同期通知」より。)

=begin original

  $dbh->do("LISTEN abc");
  $dbh->do("LISTEN def");

  ## Hang around until we get the message we want
  LISTENLOOP: {
    while (my $notify = $dbh->pg_notifies) {
      my ($name, $pid, $payload) = @$notify;
      print qq{I received notice "$name" from PID $pid, payload was "$payload"\n};
      ## Do something based on the notice received
    }
    $dbh->ping() or die qq{Ping failed!};
    $dbh->commit();
    sleep(5);
    redo;
  }

=end original

  $dbh->do("LISTEN abc");
  $dbh->do("LISTEN def");

  ## ほしい通知が来るまで待つ
  LISTENLOOP: {
    while (my $notify = $dbh->pg_notifies) {
      my ($name, $pid, $payload) = @$notify;
      print qq{I received notice "$name" from PID $pid, payload was "$payload"\n};
      ## 受け取った通知に基づいて、何かする
    }
    $dbh->ping() or die qq{Ping failed!};
    $dbh->commit();
    sleep(5);
    redo;
  }

=begin original

Payloads will always be an empty string unless you are connecting to a Postgres 
server version 9.0 or higher.

=end original

Postgres version 9.0 かそれ以上につないでいない限り、通知パラメータは常に空の文字列です。

=head3 B<ping>

  $rv = $dbh->ping;

=begin original

This C<ping> method is used to check the validity of a database handle. The value returned is 
either 0, indicating that the connection is no longer valid, or a positive integer, indicating 
the following:

  Value    Meaning
  --------------------------------------------------
    1      Database is idle (not in a transaction)
    2      Database is active, there is a command in progress (usually seen after a COPY command)
    3      Database is idle within a transaction
    4      Database is idle, within a failed transaction

=end original

C<ping> メソッドは、データベースハンドルが有効かどうかチェックするのに使用されます。
戻り値 0 は、接続がもう有効でないことを示し、正整数は次のことを示します:

  Value    Meaning
  --------------------------------------------------
    1      データベースはアイドルです (トランザクションの中にはありません)
    2      データベースは有効で、コマンドの処理中です (普通 COPY コマンドの後で見られる)
    3      データベースはアイドルで、トランザクションの中にあります
    4      データベースはアイドルで、失敗したトランザクションの中にあります

=begin original

Additional information on why a handle is not valid can be obtained by using the 
L</pg_ping> method.

=end original

ハンドルがなぜ有効でないのか、についての追加の情報は
L</pg_ping> メソッドで手に入れることができます。

=head3 B<pg_ping>

  $rv = $dbh->pg_ping;

=begin original

This is a DBD::Pg-specific extension to the L</ping> method. This will check the 
validity of a database handle in exactly the same way as C<ping>, but instead of 
returning a 0 for an invalid connection, it will return a negative number. So in 
addition to returning the positive numbers documented for C<ping>, it may also 
return the following:

  Value    Meaning
  --------------------------------------------------
   -1      There is no connection to the database at all (e.g. after C<disconnect>)
   -2      An unknown transaction status was returned (e.g. after forking)
   -3      The handle exists, but no data was returned from a test query.

=end original

これは DBD::Pg 独自の L</ping> の拡張です。データベースハンドルの有効性を C<ping>
とまったく同じ方法でチェックしますが、接続が有効でないときに 0 を返すのではなく、
代わりに負の数を返します。C<ping> に記述されている正整数に加え、以下の負数を返します:

  Value    Meaning
  --------------------------------------------------
   -1      接続がありません (例: C<disconnect> の後)
   -2      不明なトランザクションステータスが返りました (例: fork の後)
   -3      ハンドルはありますが、テストクエリに対して返答がありません

=begin original

In practice, you should only ever see -1 and -2.

=end original

実際のところ、あなたは -1 か -2 しか見ることは無いでしょう。

=head3 B<get_info>

  $value = $dbh->get_info($info_type);

=begin original

Supports a very large set (> 250) of the information types, including the minimum 
recommended by DBI.

(訳注: XXX)

=end original

=head3 B<table_info>

  $sth = $dbh->table_info(undef, $schema, $table, $type);

=begin original

Returns all tables and views visible to the current user. 
The schema and table arguments will do a C<LIKE> search if a percent sign (C<%>) or an 
underscore (C<_>) is detected in the argument. The C<$type> argument accepts a value of either 
"TABLE" or "VIEW" (using both is the default action). Note that a statement handle is returned, 
and not a direct list of tables. See the examples below for ways to handle this.

=end original

現在のユーザに見える全てのテーブルとビューを返します。
schema と table の引数の中にパーセント (C<%>) かアンダースコア (C<_>) を見つけた場合には
C<LIKE> を使ったサーチを行います。C<$type> 引数は "TABLE" か "VIEW" を受け付けます。
(デフォルトは、両方を指定したことと同じです)
テーブル名のリストが返されるのではなく、ステートメントハンドルが返されることに注意してください。
このハンドルの扱い方の例が下にあります。

=begin original

The following fields are returned:

B<TABLE_CAT>: Always NULL, as Postgres does not have the concept of catalogs.

B<TABLE_SCHEM>: The name of the schema that the table or view is in.

B<TABLE_NAME>: The name of the table or view.

B<TABLE_TYPE>: The type of object returned. Will be one of "TABLE", "VIEW", 
or "SYSTEM TABLE".

The TABLE_SCHEM and TABLE_NAME will be quoted via C<quote_ident()>.

Two additional fields specific to DBD::Pg are returned:

B<pg_schema>: the unquoted name of the schema

B<pg_table>: the unquoted name of the table

If your database supports tablespaces (version 8.0 or greater), two additional
DBD::Pg specific fields are returned:

B<pg_tablespace_name>: the name of the tablespace the table is in

B<pg_tablespace_location>: the location of the tablespace the table is in

Tables that have not been assigned to a particular tablespace (or views) 
will return NULL (C<undef>) for both of the above field.

Rows are returned alphabetically, with all tables first, and then all views.

=end original

以下のフィールドが返されます:

B<TABLE_CAT>: 常に NULL です。Postgres にはこの概念はありません。

B<TABLE_SCHEM>: そのテーブルかビューが存在するスキーマの名前

B<TABLE_NAME>: テーブルかビューの名前

B<TABLE_TYPE>: 返されたオブジェクトのタイプ。"TABLE", "VIEW", "SYSTEM TABLE" のいずれか。

TABLE_SCHEM と TABLE_NAME は C<quote_ident()> でクォートされて返されます。

DBD::Pg 特有のフィールドも、2つ追加で返されます:

B<pg_schema>: クォートされてないスキーマ名

B<pg_table>: クォートされていないテーブル名

もし、あなたのデータベースがテーブル空間をサポートしているなら (version 8.0 以上)
さらに2つの DBD::Pg 特有のフィールドが追加されます:

B<pg_tablespace_name>: そのテーブルが存在するテーブル空間名

B<pg_tablespace_location>: そのテーブルが存在するテーブル空間の LOCATION

テーブルが特定のテーブルスペースに割り当てられていない場合、
上記2つのフィールドには NULL (C<undef>) が返されます。

行はアルファベット順に、テーブルが先、ビューが後に返されます。

=begin original

Examples of use:

  ## Display all tables and views in the public schema:
  $sth = $dbh->table_info('', 'public', undef, undef);
  for my $rel (@{$sth->fetchall_arrayref({})}) {
    print "$rel->{TABLE_TYPE} name is $rel->{TABLE_NAME}\n";
  }


  # Display the schema of all tables named 'foo':
  $sth = $dbh->table_info('', undef, 'foo', 'TABLE');
  for my $rel (@{$sth->fetchall_arrayref({})}) {
    print "Table name is $rel->{TABLE_SCHEM}.$rel->{TABLE_NAME}\n";
  }

=end original

使用例:

  ## public スキーマの中のテーブルとビューを全て表示
  $sth = $dbh->table_info('', 'public', undef, undef);
  for my $rel (@{$sth->fetchall_arrayref({})}) {
    print "$rel->{TABLE_TYPE} name is $rel->{TABLE_NAME}\n";
  }


  # 'foo' という名前のテーブルを持つスキーマを全て表示 XXX
  $sth = $dbh->table_info('', undef, 'foo', 'TABLE');
  for my $rel (@{$sth->fetchall_arrayref({})}) {
    print "Table name is $rel->{TABLE_SCHEM}.$rel->{TABLE_NAME}\n";
  }

=head3 B<column_info>

  $sth = $dbh->column_info( undef, $schema, $table, $column );

=begin original

Supported by this driver as proposed by DBI with the follow exceptions.
These fields are currently always returned with NULL (C<undef>) values:

=end original

DBI の提案によりこのドライバでサポートされていますが、以下の例外があります。
これらのフィールドは、今のところ常に NULL (C<undef>) で返されます:

   TABLE_CAT
   BUFFER_LENGTH
   DECIMAL_DIGITS
   NUM_PREC_RADIX
   SQL_DATA_TYPE
   SQL_DATETIME_SUB
   CHAR_OCTET_LENGTH

=begin original

Also, six additional non-standard fields are returned:

=end original

まだ、6つの非標準のフィールドが追加されます:

=begin original

B<pg_type>: data type with additional info i.e. "character varying(20)"

B<pg_constraint>: holds column constraint definition

B<pg_schema>: the unquoted name of the schema

B<pg_table>: the unquoted name of the table

B<pg_column>: the unquoted name of the column

B<pg_enum_values>: an array reference of allowed values for an enum column

=end original

B<pg_type>: データ型とその追加情報、例えば "character varying(20)"

B<pg_constraint>: カラムの制約定義

B<pg_schema>: クォートされていないスキーマ名

B<pg_table>: クォートされていないテーブル名

B<pg_column>: クォートされていないカラム名

B<pg_enum_values>: 列挙型カラムの、許される値の配列のリファレンス

=begin original

Note that the TABLE_SCHEM, TABLE_NAME, and COLUMN_NAME fields all return 
output wrapped in quote_ident(). If you need the unquoted version, use 
the pg_ fields above.

=end original

TABLE_SCHEM, TABLE_NAME, そして COLUMN_NAME のフィールドはは全て quote_indent() によって
包まれていることに注意してください。もし、クォートされていないほうがほしい場合は、上記の
pg_ フィールドを使ってください。

=head3 B<primary_key_info>

  $sth = $dbh->primary_key_info( undef, $schema, $table, \%attr );

=begin original

Supported by this driver as proposed by DBI. There are no search patterns allowed,
but leaving the $schema argument blank will cause the first table found in the schema 
search path to be used. An additional field, "DATA_TYPE", is returned and 
shows the data type for each of the arguments in the "COLUMN_NAME" field.

=end original

DBI の提案によりこのドライバでサポートされています。サーチパターンは許されていませんが
$schema を空にしておくと、スキーマサーチパスを使って最初に見つかったテーブルが使われます。
"COLUMN_NAME" フィールドのそれぞれのデータ型を示す "DATA_TYPE" フィールドも追加で返されます。

(訳注: サーチパターン)

=begin original

This method will also return tablespace information for servers that support
tablespaces. See the L</table_info> entry for more information.

=end original

このメソッドはサーバがテーブルスペースをサポートしているときはテーブルスペースの情報も返します。
さらなる情報は L<table_info> をご覧ください。

=begin original

The five additional custom fields returned are:

B<pg_tablespace_name>: name of the tablespace, if any

B<pg_tablespace_location>: location of the tablespace

B<pg_schema>: the unquoted name of the schema

B<pg_table>: the unquoted name of the table

B<pg_column>: the unquoted name of the column

=end original

追加で返される5つのフィールド:

B<pg_tablespace_name>: テーブルスペースの名前。（もしあれば）

B<pg_tablespace_location>: テーブルスペースの位置

B<pg_schema>: クォートされていないスキーマ名

B<pg_table>: クォートされていないテーブル名

B<pg_column>: クォートされていないカラム名

=begin original

In addition to the standard format of returning one row for each column
found for the primary key, you can pass the C<pg_onerow> attribute to force
a single row to be used. If the primary key has multiple columns, the
"KEY_SEQ", "COLUMN_NAME", and "DATA_TYPE" fields will return a comma-delimited
string. If the C<pg_onerow> attribute is set to "2", the fields will be
returned as an arrayref, which can be useful when multiple columns are
involved:

=end original

プライマリキーのカラムが見つかるごとに1つの行を返す標準の形式に加え、C<pg_onerow> 属性を
渡すことで、プライマリキーが複数カラムに渡る場合であっても1つの行を返すように強制できます。
プライマリキーが複数カラムに渡る場合、"KEY_SEQ", "COLUMN_NAME", "DATA_TYPE" の3つのフィールド
は、カンマ区切りの文字列で返されます。もし C<pg_onerow> 属性に "2" が設定されていると、これらの
フィールドは arrayref で返されます。複数カラムが含まれる場合は便利でしょう:

  $sth = $dbh->primary_key_info('', '', 'dbd_pg_test', {pg_onerow => 2});
  if (defined $sth) {
    my $pk = $sth->fetchall_arrayref()->[0];
    print "Table $pk->[2] has a primary key on these columns:\n";
    for (my $x=0; defined $pk->[3][$x]; $x++) {
      print "Column: $pk->[3][$x]  (data type: $pk->[6][$x])\n";
    }
  }

(訳注: C<pg_onerow> 属性に "0" を設定しても、"1"
を設定している時と同様にカンマ区切りになる模様。
複数のプライマリキー・カラムに対して、複数の行を得たい場合は、C<pg_onerow>
自体を指定しないでおく必要がある)

=head3 B<primary_key>

  @key_column_names = $dbh->primary_key(undef, $schema, $table);

=begin original

Simple interface to the L</primary_key_info> method. Returns a list of the column names that 
comprise the primary key of the specified table. The list is in primary key column sequence 
order. If there is no primary key then an empty list is returned.

=end original

L</primary_key_info> メソッドへのシンプルなインタフェースです。
指定されたテーブルのプライマリキーを構成するカラム名をリストで返します。
このリストは、プライマリキー指定時のカラムの記述順で返されます。
プライマリキーがない場合は、空のリストが返されます。

=head3 B<foreign_key_info>

  $sth = $dbh->foreign_key_info( $pk_catalog, $pk_schema, $pk_table,
                                 $fk_catalog, $fk_schema, $fk_table );

=begin original

Supported by this driver as proposed by DBI, using the SQL/CLI variant.
There are no search patterns allowed, but leaving the C<$schema> argument
blank will cause the first table found in the schema search path to be
used. Two additional fields, "UK_DATA_TYPE" and "FK_DATA_TYPE", are returned
to show the data type for the unique and foreign key columns. Foreign
keys that have no named constraint (where the referenced column only has
an unique index) will return C<undef> for the "UK_NAME" field.

=end original

DBI の提案によりこのドライバでサポートされています。SQL/CLI variant を使っています。
サーチパターンは許されていませんが、C<$schema> 引数を空にしておくと
スキーマサーチパスを使って最初に見つかったテーブルが使われます。
2つのフィールド "UK_DATA_TYPE" と "FK_DATA_TYPE"
が一意性制約と外部キー制約のデータ型を示すために追加で返されます。
名前のない外部キー制約には "UK_NAME" フィールドに C<undef> が返されます。

=head3 B<statistics_info>

  $sth = $dbh->statistics_info( undef, $schema, $table, $unique_only, $quick );

=begin original

Returns a statement handle that can be fetched from to give statistics information 
on a specific table and its indexes. The C<$table> argument is mandatory. The 
C<$schema> argument is optional but recommended. The C<$unique_only> argument, if true, 
causes only information about unique indexes to be returned. The C<$quick> argument is 
not used by DBD::Pg. For information on the format of the rows returned, please see the DBI 
documentation.

=end original

指定されたテーブルとそのインデックスの情報を読み取ることができるステートメントハンドルを返します。
C<$table> 引数は必須です。C<$schema> 引数は省略可能ですが省略しないことが推奨されます。
C<$unique_only> 引数が真の場合、UNIQUE なインデックスのみが返されます。
C<$quick> 引数は DBD::Pg では使用されません。
返される行の形式についての情報は、DBI のドキュメントをご覧ください。

=for html <a href="http://search.cpan.org/~timb/DBI/DBI.pm#statistics_info">DBI section on statistics_info</a>

=head3 B<tables>

  @names = $dbh->tables( undef, $schema, $table, $type, \%attr );

=begin original

Supported by this driver as proposed by DBI. This method returns all tables
and/or views which are visible to the current user: see L</table_info>
for more information about the arguments. The name of the schema appears 
before the table or view name. This can be turned off by adding in the 
C<pg_noprefix> attribute:

=end original

DBI の提案によりこのドライバでサポートされています。このメソッドは、
現在のユーザで見ることができる全てのテーブルとビューを返します。
引数についての情報は L</table_info> をご覧ください。
テーブル名、ビュー名の前にスキーマ名がついた状態で返されます。これは
C<pg_noprefix> 属性で off にできます:

  my @tables = $dbh->tables( '', '', 'dbd_pg_test', '', {pg_noprefix => 1} );

=head3 B<type_info_all>

  $type_info_all = $dbh->type_info_all;

=begin original

Supported by this driver as proposed by DBI. Information is only provided for
SQL datatypes and for frequently used datatypes. The mapping between the
PostgreSQL typename and the SQL92 datatype (if possible) has been done
according to the following table:

=end original

DBI の提案によりこのドライバでサポートされています。SQL
データ型と、よく使われるデータ型の情報についてのみ返します。PostgreSQL の型名と
SQL92 の型名のマッピングは(可能であれば)、次のテーブルに従って行われます:

  +---------------+------------------------------------+
  | typname       | SQL92                              |
  |---------------+------------------------------------|
  | bool          | BOOL                               |
  | text          | /                                  |
  | bpchar        | CHAR(n)                            |
  | varchar       | VARCHAR(n)                         |
  | int2          | SMALLINT                           |
  | int4          | INT                                |
  | int8          | /                                  |
  | money         | /                                  |
  | float4        | FLOAT(p)   p<7=float4, p<16=float8 |
  | float8        | REAL                               |
  | abstime       | /                                  |
  | reltime       | /                                  |
  | tinterval     | /                                  |
  | date          | /                                  |
  | time          | /                                  |
  | datetime      | /                                  |
  | timespan      | TINTERVAL                          |
  | timestamp     | TIMESTAMP                          |
  +---------------+------------------------------------+

=head3 B<type_info>

  @type_info = $dbh->type_info($data_type);

=begin original

Returns a list of hash references holding information about one or more variants of $data_type. 
See the DBI documentation for more details.

=end original

$data_type の variants の情報を1つかそれ以上含んだ、ハッシュのリファレンスのリストを返します。
詳細は、DBI のドキュメントをご覧ください。

=head3 B<pg_server_trace>

  $dbh->pg_server_trace($filehandle);

=begin original

Writes debugging information from the PostgreSQL backend to a file. This is
not related to the DBI L</trace> method and you should not use this method unless
you know what you are doing. If you do enable this, be aware that the file
will grow very large, very quick. To stop logging to the file, use the
L</pg_server_untrace> method. The first argument must be a file handle, not
a filename. Example:

=end original

PostgreSQL バックエンドからのデバッグ情報をファイルに書き込みます。
このメソッドは DBI の L</trace> とは関係ありませんし、自分が何をしているのかわからない場合は、
このメソッドは使用するべきではありません。これを使うと、ファイルがあっという間に巨大になることに
気がつくでしょう。ファイルへの書き込みを停止させるには L</pg_server_untrace>
メソッドを使用してください。最初の引数はファイル名ではなく、ファイルハンドルでなければなりません。
例:

=begin original

  my $pid = $dbh->{pg_pid};
  my $file = "pgbackend.$pid.debug.log";
  open(my $fh, ">$file") or die qq{Could not open "$file": $!\n};
  $dbh->pg_server_trace($fh);
  ## Run code you want to trace here
  $dbh->pg_server_untrace;
  close($fh);

=end original

  my $pid = $dbh->{pg_pid};
  my $file = "pgbackend.$pid.debug.log";
  open(my $fh, ">$file") or die qq{Could not open "$file": $!\n};
  $dbh->pg_server_trace($fh);
  ## トレースしたいコードをここに書く
  $dbh->pg_server_untrace;
  close($fh);

=head3 B<pg_server_untrace>

  $dbh->pg_server_untrace;

=begin original

Stop server logging to a previously opened file.

=end original

バックエンドからのデバッグ情報をファイルに書くのを停止する。

=head3 B<selectrow_array>

  @row_ary = $dbh->selectrow_array($sql);
  @row_ary = $dbh->selectrow_array($sql, \%attr);
  @row_ary = $dbh->selectrow_array($sql, \%attr, @bind_values);

=begin original

Returns an array of row information after preparing and executing the provided SQL string.
The rows are returned by calling L</fetchrow_array>. The string can also be a statement
handle generated by a previous prepare. Note that only the first row of data is returned.
If called in a scalar context, only the first column of the first row is returned.
Because this is not portable, it is not recommended that you use this method in that way.

=end original

与えられた SQL 文字列を prepare し execute して、行の内容を配列で返します。
(訳注: 内部的には) L</fetchrow_array> を呼んでその値を返しています。
文字列の部分は、prepare で得たステートメントハンドルでも構いません。
返されるのは、最初の行だけだということに注意してください。
スカラコンテキストでは、最初の行の最初のカラムだけが返されますが、これはポータブルでは
ありませんので、このやりかたでこのメソッドを使うことは推奨されません。

=head3 B<selectrow_arrayref>

  $ary_ref = $dbh->selectrow_arrayref($statement);
  $ary_ref = $dbh->selectrow_arrayref($statement, \%attr);
  $ary_ref = $dbh->selectrow_arrayref($statement, \%attr, @bind_values);

=begin original

Exactly the same as L</selectrow_array>, except that it returns a reference to an array,
by internal use of the L</fetchrow_arrayref> method.

=end original

配列へのリファレンスを返すということを除いては L</selectrow_array> とまったく同じです。
内部的に L</fetchrow_arrayref> メソッドを使用しています。

=head3 B<selectrow_hashref>

  $hash_ref = $dbh->selectrow_hashref($sql);
  $hash_ref = $dbh->selectrow_hashref($sql, \%attr);
  $hash_ref = $dbh->selectrow_hashref($sql, \%attr, @bind_values);

=begin original

Exactly the same as L</selectrow_array>, except that it returns a reference to an hash,
by internal use of the L</fetchrow_hashref> method.

=end original

ハッシュのリファレンスを返すということを除いては L</selectrow_array> とまったく同じです。
内部的に L</fetchrow_hashref> メソッドを使用しています。

=head3 B<clone>

  $other_dbh = $dbh->clone();

=begin original

Creates a copy of the database handle by connecting with the same parameters as the original 
handle, then trying to merge the attributes. See the DBI documentation for complete usage.

=end original

オリジナルのハンドルと同じパラメータを用いて接続し、属性をマージした、
データベースハンドルのコピーを返します。
完全な使い方については DBI ドキュメントをご覧ください。

=head2 Database Handle Attributes

=head3 B<AutoCommit> (boolean)

=begin original

Supported by DBD::Pg as proposed by DBI. According to the classification of
DBI, PostgreSQL is a database in which a transaction must be explicitly
started. Without starting a transaction, every change to the database becomes
immediately permanent. The default of AutoCommit is on, but this may change
in the future, so it is highly recommended that you explicitly set it when
calling L</connect>. For details see the notes about L</Transactions>
elsewhere in this document.

=end original

DBI の提案によりこのドライバでサポートされています。DBI の分類によると、PostgreSQL
はトランザクションを明示的に開始しなければならないデータベースです。
トランザクションの開始をせずにデータベースに対して変更を行うと、その変更は直ちに永続化します。
デフォルトで AutoCommit が on というこの設計は、将来には変更するかもしれませんので、
L</connect> を呼ぶ際には明示的にこの値をセットすることを強く推奨します。
詳細ついてはこのドキュメントの L</Transactions> にあります。

=head3 B<pg_bool_tf> (boolean)

=begin original

DBD::Pg specific attribute. If true, boolean values will be returned
as the characters 't' and 'f' instead of '1' and '0'.

=end original

DBD::Pg 特有の属性です。真の場合、論理値データ型が
"1" と "0" の代わりに "t" と "f" で返されます。

=head3 B<ReadOnly> (boolean)

  $dbh->{ReadOnly} = 1;

=begin original

Specifies if the current database connection should be in read-only mode or not. 
In this mode, changes that change the database are not allowed and will throw 
an error. Note: this method will B<not> work if L</AutoCommit> is true. The 
read-only effect is accomplished by sending a S<SET TRANSACTION READ ONLY> after 
every begin. For more details, please see:

=end original

現在のデータベースへの接続を、読み取り専用モードにするかどうかを指定します。
このモードでは、データベースへの変更は許されず、エラーになります。
この方法は L</AutoCommit> が真のときはB<動きません>。読み取り専用の効果は、
begin が行われたあとに S<SET TRANSACTION READ ONLY> を送ることで成し遂げられます。
より詳細な情報については、以下を見てください:

http://www.postgresql.org/docs/current/interactive/sql-set-transaction.html

=begin original

Please not that this method is not foolproof: there are still ways to update the 
database. Consider this a safety net to catch applications that should not be 
issuing commands such as INSERT, UPDATE, or DELETE.

This method method requires DBI version 1.55 or better.

=end original

この属性は foolproof ではないことに注意してください: この属性を真にしても、データベースを
変更する方法が残されています。この属性は INSERT, UPDATE, DELETE
を発行するべきでないときのセーフティネットだと考えてください。

(訳注: 原文の Please not は Please note の typo)

=head3 B<pg_server_prepare> (integer)

=begin original

DBD::Pg specific attribute. Indicates if DBD::Pg should attempt to use server-side 
prepared statements. The default value, 1, indicates that prepared statements should 
be used whenever possible. See the section on the L</prepare> method for more information.

=end original

DBD::Pg 特有の属性です。DBD::Pg がサーバサイドのプリペアド文を使おうとするかどうかを
指定します。デフォルトは 1 で、可能な場合は常にプリペアド文を使用します。詳細については、
L</prepare> のセクションをご覧ください。

=head3 B<pg_placeholder_dollaronly> (boolean)

=begin original

DBD::Pg specific attribute. Defaults to false. When true, question marks inside of statements 
are not treated as L<placeholders|/Placeholders>.
Useful for statements that contain unquoted question marks, such as geometric operators.

=end original

DBD::Pg 特有の属性です。デフォルトは偽です。真のとき、SQL 文中のクエスチョンマークは
L<placeholders|/Placeholders> とはみなされません。
幾何データ演算子のようなクエスチョンマークを中に含む　SQL 文を使うときに便利です。

(訳注: この属性が真のときには ":foo" という形式の "named parameters" で使われるコロンもまた、
プレースホルダの開始文字とはみなされなくなります。)

=head3 B<pg_enable_utf8> (boolean)

=begin original

DBD::Pg specific attribute. If true, then the C<utf8> flag will be turned on
for returned character data (if the data is valid UTF-8). For details about
the C<utf8> flag, see the C<Encode> module. This attribute is only relevant under
perl 5.8 and later.

=end original

DBD::Pg 特有の属性です。真の場合、返された文字データの C<utf8> フラグが on になります。(UTF-8
として正しいデータの場合) C<utf8> フラグの詳細については C<Encode>
モジュールを見てください。この属性は Perl 5.8 かそれ以降のみに関係します。

=head3 B<pg_errorlevel> (integer)

=begin original

DBD::Pg specific attribute. Sets the amount of information returned by the server's 
error messages. Valid entries are 0, 1, and 2. Any other number will be forced to the 
default value of 1.

=end original

DBD::Pg 特有の属性です。どれだけの量の情報がサーバのエラーメッセージとして返されるかを設定します。
0, 1, そして 2 が設定でき、それ以外の数値を設定するとデフォルトの値 1 に強制されます。

=begin original

A value of 0 ("TERSE") will show severity, primary text, and position only
and will usually fit on a single line. A value of 1 ("DEFAULT") will also
show any detail, hint, or context fields. A value of 2 ("VERBOSE") will
show all available information.

=end original

値 0 ("TERSE") ("簡潔") は、飾りのない、主要なテキスト、ポジションだけを表示し、
たいてい一行に収まります。
値 1 ("DEFAULT") ("デフォルト") は、詳細、ヒント、文脈も表示します。
値 2 ("VERBOSE") ("饒舌") は、可能な限り全ての情報を表示します。

(訳注: XXX)

=head3 B<pg_lib_version> (integer, read-only)

=begin original

DBD::Pg specific attribute. Indicates which version of PostgreSQL that 
DBD::Pg was compiled against. In other words, which libraries were used. 
Returns a number with major, minor, and revision together; version 8.1.4 
would be returned as C<80104>.

=end original

DBD::Pg 特有の属性です。どのバージョンの PostgreSQL に対して DBD::Pg がコンパイルされたかを示します。
言い換えると、どのライブラリが使われるかを示します。
メジャー、マイナー、リビジョン番号を繋げた1つの数を返します。バージョン 8.1.4 だと C<80104>
になります。

=head3 B<pg_server_version> (integer, read-only)

=begin original

DBD::Pg specific attribute. Indicates which version of PostgreSQL that 
the current database handle is connected to. Returns a number with major, 
minor, and revision together; version 8.0.1 would be C<80001>.

=end original

DBD::Pg 特有の属性です。現在のデータベースハンドルが、どのバージョンの PostgreSQL
に接続しているかを示します。
メジャー、マイナー、リビジョン番号を繋げた1つの数を返します。バージョン 8.0.1 だと C<80001>
になります。

=head3 B<Name> (string, read-only)

=begin original

Returns the name of the current database. This is the same as the DSN, without the 
"dbi:Pg:" part. Before version 2.0.0, this only returned the bare database name 
(e.g. 'foo'). From version 2.0.0 onwards, it returns the more correct 
output (e.g. 'dbname=foo')

=end original

現在のデータベース名が返されます。これは "dbi:Pg:" 部分を除いた DSN と同じです。
バージョン 2.0.0 より前だと、裸のデータベース名が返されます。(例: 'foo')
バージョン 2.0.0 以降は、よりきちんとした出力をします。(例: 'dbname=foo')

=head3 B<Username> (string, read-only)

=begin original

Returns the name of the user connected to the database.

=end original

データベースに接続しているユーザ名を返します。

=head3 B<pg_db> (string, read-only)

=begin original

DBD::Pg specific attribute. Returns the name of the current database.

=end original

DBD::Pg 特有の属性です。現在のデータベース名を返します。

=head3 B<pg_user> (string, read-only)

=begin original

DBD::Pg specific attribute. Returns the name of the user that
connected to the server.

=end original

DBD::Pg 特有の属性です。サーバに接続しているユーザ名を返します。

=head3 B<pg_host> (string, read-only)

=begin original

DBD::Pg specific attribute. Returns the host of the current
server connection. Locally connected hosts will return an empty
string.

=end original

DBD::Pg 特有の属性です。現在のサーバ接続のホストを返します。
ローカル接続の場合は空の文字列が返されます。

=head3 B<pg_port> (integer, read-only)

=begin original

DBD::Pg specific attribute. Returns the port of the connection to
the server.

=end original

DBD::Pg 特有の属性です。現在のサーバ接続のポートを返します。

=head3 B<pg_socket> (integer, read-only)

=begin original

DBD::Pg specific attribute. Returns the file description number of
the connection socket to the server.

=end original

DBD::Pg 特有の属性です。現在のサーバ接続のソケットの記述子を返します。

=head3 B<pg_pass> (string, read-only)

=begin original

DBD::Pg specific attribute. Returns the password used to connect
to the server.

=end original

DBD::Pg 特有の属性です。現在のサーバ接続に使用されているパスワードを返します。

=head3 B<pg_options> (string, read-only)

=begin original

DBD::Pg specific attribute. Returns the command-line options passed
to the server. May be an empty string.

=end original

DBD::Pg 特有の属性です。サーバに渡されたコマンドラインオプションを返します。
空文字列かもしれません。

=head3 B<pg_default_port> (integer, read-only)

=begin original

DBD::Pg specific attribute. Returns the default port used if none is
specifically given.

=end original

DBD::Pg 特有の属性です。ポートが指定されなかったときのデフォルトのポート番号を返します。

=head3 B<pg_pid> (integer, read-only)

=begin original

DBD::Pg specific attribute. Returns the process id (PID) of the
backend server process handling the connection.

=end original

DBD::Pg 特有の属性です。この接続を取り扱っているバックエンドサーバプロセスのプロセス ID
(PID) を返します。

=head3 B<pg_prepare_now> (boolean)

=begin original

DBD::Pg specific attribute. Default is off. If true, then the L</prepare> method will 
immediately prepare commands, rather than waiting until the first execute.

=end original

DBD::Pg 特有の属性です。デフォルトは off です。真の場合、L</prepare> メソッドは
直ちに PREPARE 文を発行します。偽の場合 PREPARE 文の発行は最初の execute のときまで待ちます。

=head3 B<pg_expand_array> (boolean)

=begin original

DBD::Pg specific attribute. Defaults to true. If false, arrays returned from the server will 
not be changed into a Perl arrayref, but remain as a string.

=end original

DBD::Pg 特有の属性です。デフォルトは真です。偽の場合、サーバから返された配列を Perl
の配列のリファレンスに変換せず、文字列のままにされます。

=head3 B<pg_async_status> (integer, read-only)

=begin original

DBD::Pg specific attribute.
Returns the current status of an L<asynchronous|/Asynchronous Queries> command.
0 indicates no asynchronous command is in progress, 1 indicates that an asynchronous
command has started and -1 indicated that an asynchronous command has been cancelled.

=end original

DBD::Pg 特有の属性です。現在の非同期クエリ L<asynchronous|/Asynchronous Queries> の状態を返します。
0 は実行中の非同期クエリがないことを示します。1 は非同期クエリがスタートしたことを、-1
は非同期クエリがキャンセルされたことを示します。

=head3 B<pg_standard_conforming_strings> (boolean, read-only)

=begin original

DBD::Pg specific attribute. Returns true if the server is currently using 
standard conforming strings. Only available if the target 
server is version 8.2 or better.

=end original

DBD::Pg 特有の属性です。サーバが標準準拠文字列を使用している場合には真の値が返されます。
この値はサーバのバージョンが 8.2 かそれ以上の場合のみ有効です。

=head3 B<pg_INV_READ> (integer, read-only)

=begin original

Constant to be used for the mode in L</lo_creat> and L</lo_open>.

=end original

L</lo_creat> と L</lo_open> でモードとして使われる定数。

=head3 B<pg_INV_WRITE> (integer, read-only)

=begin original

Constant to be used for the mode in L</lo_creat> and L</lo_open>.

=end original

L</lo_creat> と L</lo_open> でモードとして使われる定数。

=head3 B<Driver> (handle, read-only)

=begin original

Holds the handle of the parent driver. The only recommended use for this is to find the name 
of the driver using:
=end original

親ドライバのハンドルを保持します。親ハンドルの名前を見つけるためだけに使うことが推奨されます。

  $dbh->{Driver}->{Name}

=head3 B<pg_protocol> (integer, read-only)

=begin original

DBD::Pg specific attribute. Returns the version of the PostgreSQL server.
If DBD::Pg is unable to figure out the version, it will return a "0". Otherwise,
a "3" is returned.

=end original

DBD::Pg 特有の属性です。PostgreSQL サーバの (訳注: プロトコルの) バージョンを返します。
DBD::Pg がバージョンを調べることができなかったときは
"0" が返されます。さもなければ "3" が返されます。

=head3 B<RowCacheSize>

=begin original

Not used by DBD::Pg

=end original

DBD::Pg では使用されません。

=head1 DBI STATEMENT HANDLE OBJECTS

=head2 Statement Handle Methods

=head3 B<bind_param>

  $rv = $sth->bind_param($param_num, $bind_value);
  $rv = $sth->bind_param($param_num, $bind_value, $bind_type);
  $rv = $sth->bind_param($param_num, $bind_value, \%attr);

=begin original

Allows the user to bind a value and/or a data type to a placeholder. This is
especially important when using server-side prepares. See the 
L</prepare> method for more information.

=end original

このメソッドで、プレースホルダに対して値やデータ型を割り当てることができます。
これは、サーバサイドの prepare を使っているときには特に重要です。
より詳しい情報が L</prepare> にあります。

=begin original

The value of C<$param_num> is a number if using the '?' or '$1' style
placeholders. If using ":foo" style placeholders, the complete name
(e.g. ":foo") must be given. For numeric values, you can either use a
number or use a literal '$1'. See the examples below.

=end original

C<$param_num> の値は、'?' や '$1' スタイルのプレースホルダを使っている場合は
数値を与えてください。":foo" スタイルのプレースホルダの場合は、完全な名前を与えなければなりません。
(例: ":foo") 
数値を与えるときは、単に数値を与えてもよいですし、リテラルの '$1' 等と書くことも出来ます。
下の例をみてください。

=begin original

The C<$bind_value> argument is fairly self-explanatory. A value of C<undef> will
bind a C<NULL> to the placeholder. Using C<undef> is useful when you want
to change just the type and will be overwriting the value later.
(Any value is actually usable, but C<undef> is easy and efficient).

=end original

C<$bind_value> は、ある程度自己説明的な引数です。
値 C<undef> を与えると、プレースホルダに C<NULL> を割り当てます。
割り当てる型を変更して、値はあとから上書きしたい、というときに C<undef> は便利です。
(実際には、どんな値を与えてもかまいませんが、C<undef> を使うのが簡単で能率的でしょう。)

=begin original

The C<\%attr> hash is used to indicate the data type of the placeholder.
The default value is "varchar". If you need something else, you must
use one of the values provided by DBI or by DBD::Pg. To use a SQL value,
modify your "use DBI" statement at the top of your script as follows:

=end original

C<\%attr> は、プレースホルダのデータ型を示すのに使います。デフォルトは "varchar"
です。他の型にしたいときは、DBI か DBD::Pg
によって提供されている値のどれかを使わなければなりません。SQL
のデータ型を使う場合は、あなたのスクリプトの冒頭の "use DBI" を以下のように編集してください:

  use DBI qw(:sql_types);

=begin original

This will import some constants into your script. You can plug those
directly into the L</bind_param> call. Some common ones that you will
encounter are:

=end original

これで、いくつかの定数をあなたのスクリプトにインポートするようになります。
これらの定数は L</bind_param> 呼び出しに直接書くことが出来ます。
あなたが遭遇するであろう例としては:

  SQL_INTEGER

=begin original

To use PostgreSQL data types, import the list of values like this:

=end original

PostgreSQL のデータ型を使うには、このように値のリストをインポートしてください:

  use DBD::Pg qw(:pg_types);

=begin original

You can then set the data types by setting the value of the C<pg_type>
key in the hash passed to L</bind_param>.
The current list of Postgres data types exported is:

=end original

そのうえで、L</bind_param> に渡すハッシュのキーとして C<pg_type> を使い、
値として、そのデータ型をセットしてください。
現在エクスポートされる Postgres のデータ型のリスト:

 PG_ABSTIME PG_ABSTIMEARRAY PG_ACLITEM PG_ACLITEMARRAY PG_ANY PG_ANYARRAY
 PG_ANYELEMENT PG_ANYENUM PG_ANYNONARRAY PG_BIT PG_BITARRAY PG_BOOL
 PG_BOOLARRAY PG_BOX PG_BOXARRAY PG_BPCHAR PG_BPCHARARRAY PG_BYTEA
 PG_BYTEAARRAY PG_CHAR PG_CHARARRAY PG_CID PG_CIDARRAY PG_CIDR
 PG_CIDRARRAY PG_CIRCLE PG_CIRCLEARRAY PG_CSTRING PG_CSTRINGARRAY PG_DATE
 PG_DATEARRAY PG_FLOAT4 PG_FLOAT4ARRAY PG_FLOAT8 PG_FLOAT8ARRAY PG_GTSVECTOR
 PG_GTSVECTORARRAY PG_INET PG_INETARRAY PG_INT2 PG_INT2ARRAY PG_INT2VECTOR
 PG_INT2VECTORARRAY PG_INT4 PG_INT4ARRAY PG_INT8 PG_INT8ARRAY PG_INTERNAL
 PG_INTERVAL PG_INTERVALARRAY PG_LANGUAGE_HANDLER PG_LINE PG_LINEARRAY PG_LSEG
 PG_LSEGARRAY PG_MACADDR PG_MACADDRARRAY PG_MONEY PG_MONEYARRAY PG_NAME
 PG_NAMEARRAY PG_NUMERIC PG_NUMERICARRAY PG_OID PG_OIDARRAY PG_OIDVECTOR
 PG_OIDVECTORARRAY PG_OPAQUE PG_PATH PG_PATHARRAY PG_PG_ATTRIBUTE PG_PG_CLASS
 PG_PG_PROC PG_PG_TYPE PG_POINT PG_POINTARRAY PG_POLYGON PG_POLYGONARRAY
 PG_RECORD PG_RECORDARRAY PG_REFCURSOR PG_REFCURSORARRAY PG_REGCLASS PG_REGCLASSARRAY
 PG_REGCONFIG PG_REGCONFIGARRAY PG_REGDICTIONARY PG_REGDICTIONARYARRAY PG_REGOPER PG_REGOPERARRAY
 PG_REGOPERATOR PG_REGOPERATORARRAY PG_REGPROC PG_REGPROCARRAY PG_REGPROCEDURE PG_REGPROCEDUREARRAY
 PG_REGTYPE PG_REGTYPEARRAY PG_RELTIME PG_RELTIMEARRAY PG_SMGR PG_TEXT
 PG_TEXTARRAY PG_TID PG_TIDARRAY PG_TIME PG_TIMEARRAY PG_TIMESTAMP
 PG_TIMESTAMPARRAY PG_TIMESTAMPTZ PG_TIMESTAMPTZARRAY PG_TIMETZ PG_TIMETZARRAY PG_TINTERVAL
 PG_TINTERVALARRAY PG_TRIGGER PG_TSQUERY PG_TSQUERYARRAY PG_TSVECTOR PG_TSVECTORARRAY
 PG_TXID_SNAPSHOT PG_TXID_SNAPSHOTARRAY PG_UNKNOWN PG_UUID PG_UUIDARRAY PG_VARBIT
 PG_VARBITARRAY PG_VARCHAR PG_VARCHARARRAY PG_VOID PG_XID PG_XIDARRAY
 PG_XML PG_XMLARRAY

=begin original

Data types are "sticky," in that once a data type is set to a certain placeholder,
it will remain for that placeholder, unless it is explicitly set to something
else afterwards. If the statement has already been prepared, and you switch the
data type to something else, DBD::Pg will re-prepare the statement for you before
doing the next execute.

=end original

データ型は "sticky" です。あるプレースホルダにデータ型をいったん設定すると、明示的に他の型を
セットしない限り、そのプレースホルダの型として記憶されます。
ステートメントが既に prepare されていて、そこにデータ型を他のものに変更すると DBD::Pg
は、次の execute までのあいだに文を再度 prepare します。

=begin original

Examples:

  use DBI qw(:sql_types);
  use DBD::Pg qw(:pg_types);

  $SQL = "SELECT id FROM ptable WHERE size > ? AND title = ?";
  $sth = $dbh->prepare($SQL);

  ## Both arguments below are bound to placeholders as "varchar"
  $sth->execute(123, "Merk");

  ## Reset the datatype for the first placeholder to an integer
  $sth->bind_param(1, undef, SQL_INTEGER);

  ## The "undef" bound above is not used, since we supply params to execute
  $sth->execute(123, "Merk");

  ## Set the first placeholder's value and data type
  $sth->bind_param(1, 234, { pg_type => PG_TIMESTAMP });

  ## Set the second placeholder's value and data type.
  ## We don't send a third argument, so the default "varchar" is used
  $sth->bind_param('$2', "Zool");

  ## We realize that the wrong data type was set above, so we change it:
  $sth->bind_param('$1', 234, { pg_type => SQL_INTEGER });

  ## We also got the wrong value, so we change that as well.
  ## Because the data type is sticky, we don't need to change it
  $sth->bind_param(1, 567);

  ## This executes the statement with 567 (integer) and "Zool" (varchar)
  $sth->execute();

=end original

例:

  use DBI qw(:sql_types);
  use DBD::Pg qw(:pg_types);

  $SQL = "SELECT id FROM ptable WHERE size > ? AND title = ?";
  $sth = $dbh->prepare($SQL);

  ## Both arguments below are bound to placeholders as "varchar"
  $sth->execute(123, "Merk");

  ## Reset the datatype for the first placeholder to an integer
  $sth->bind_param(1, undef, SQL_INTEGER);

  ## The "undef" bound above is not used, since we supply params to execute
  $sth->execute(123, "Merk");

  ## Set the first placeholder's value and data type
  $sth->bind_param(1, 234, { pg_type => PG_TIMESTAMP });

  ## Set the second placeholder's value and data type.
  ## We don't send a third argument, so the default "varchar" is used
  $sth->bind_param('$2', "Zool");

  ## We realize that the wrong data type was set above, so we change it:
  $sth->bind_param('$1', 234, { pg_type => SQL_INTEGER });

  ## We also got the wrong value, so we change that as well.
  ## Because the data type is sticky, we don't need to change it
  $sth->bind_param(1, 567);

  ## This executes the statement with 567 (integer) and "Zool" (varchar)
  $sth->execute();

=head3 B<bind_param_inout>

  $rv = $sth->bind_param_inout($param_num, \$scalar, 0);

Experimental support for this feature is provided. The first argument to 
bind_param_inout should be a placeholder number. The second argument 
should be a reference to a scalar variable in your script. The third argument 
is not used and should simply be set to 0. Note that what this really does is 
assign a returned column to the variable, in the order in which the column 
appears. For example:

  my $foo = 123;
  $sth = $dbh->prepare("SELECT 1+?::int");
  $sth->bind_param_inout(1, \$foo, 0);
  $foo = 222;
  $sth->execute(444);
  $sth->fetch;

The above will cause $foo to have a new value of "223" after the final fetch.
Note that the variables bound in this manner are very sticky, and will trump any 
values passed in to execute. This is because the binding is done as late as possible, 
at the execute() stage, allowing the value to be changed between the time it was bound 
and the time the query is executed. Thus, the above execute is the same as:

  $sth->execute();

=head3 B<bind_param_array>


  $rv = $sth->bind_param_array($param_num, $array_ref_or_value)
  $rv = $sth->bind_param_array($param_num, $array_ref_or_value, $bind_type)
  $rv = $sth->bind_param_array($param_num, $array_ref_or_value, \%attr)

Binds an array of values to a placeholder, so that each is used in turn by a call 
to the L</execute_array> method.

=head3 B<execute>

  $rv = $sth->execute(@bind_values);

Executes a previously prepared statement. In addition to C<UPDATE>, C<DELETE>,
C<INSERT> statements, for which it returns always the number of affected rows,
the C<execute> method can also be used for C<SELECT ... INTO table> statements.

The "prepare/bind/execute" process has changed significantly for PostgreSQL
servers 7.4 and later: please see the C<prepare()> and C<bind_param()> entries for
much more information.

Setting one of the bind_values to "undef" is the equivalent of setting the value 
to NULL in the database. Setting the bind_value to $DBDPG_DEFAULT is equivalent 
to sending the literal string 'DEFAULT' to the backend. Note that using this 
option will force server-side prepares off until such time as PostgreSQL 
supports using DEFAULT in prepared statements.

DBD::Pg also supports passing in arrays to execute: simply pass in an arrayref, 
and DBD::Pg will flatten it into a string suitable for input on the backend.

If you are using Postgres version 8.2 or greater, you can also use any of the 
fetch methods to retrieve the values of a C<RETURNING> clause after you execute 
an C<UPDATE>, C<DELETE>, or C<INSERT>. For example:

  $dbh->do(q{CREATE TABLE abc (id SERIAL, country TEXT)});
  $SQL = q{INSERT INTO abc (country) VALUES (?) RETURNING id};
  $sth = $dbh->prepare($SQL);
  $sth->execute('France');
  $countryid = $sth->fetch()->[0];
  $sth->execute('New Zealand');
  $countryid = $sth->fetch()->[0];

=head3 B<execute_array>

  $tuples = $sth->execute_array() or die $sth->errstr;
  $tuples = $sth->execute_array(\%attr) or die $sth->errstr;
  $tuples = $sth->execute_array(\%attr, @bind_values) or die $sth->errstr;

  ($tuples, $rows) = $sth->execute_array(\%attr) or die $sth->errstr;
  ($tuples, $rows) = $sth->execute_array(\%attr, @bind_values) or die $sth->errstr;

Execute a prepared statement once for each item in a passed-in hashref, or items that 
were previously bound via the L</bind_param_array> method. See the DBI documentation 
for more details.

=head3 B<execute_for_fetch>

  $tuples = $sth->execute_for_fetch($fetch_tuple_sub);
  $tuples = $sth->execute_for_fetch($fetch_tuple_sub, \@tuple_status);

  ($tuples, $rows) = $sth->execute_for_fetch($fetch_tuple_sub);
  ($tuples, $rows) = $sth->execute_for_fetch($fetch_tuple_sub, \@tuple_status);

Used internally by the L</execute_array> method, and rarely used directly. See the 
DBI documentation for more details.

=head3 B<fetchrow_arrayref>

  $ary_ref = $sth->fetchrow_arrayref;

Fetches the next row of data from the statement handle, and returns a reference to an array 
holding the column values. Any columns that are NULL are returned as undef within the array.

If there are no more rows or if an error occurs, the this method return undef.
You should check C<< $sth->err >> afterwards (or use the L</RaiseError> attribute)
to discover if the undef returned was due to an error.

Note that the same array reference is returned for each fetch, so don't store the reference and 
then use it after a later fetch. Also, the elements of the array are also reused for each row, 
so take care if you want to take a reference to an element. See also L</bind_columns>.

=head3 B<fetchrow_array>

  @ary = $sth->fetchrow_array;

Similar to the L</fetchrow_arrayref> method, but returns a list of column information
rather than a reference to a list. Do not use this in a scalar context.

=head3 B<fetchrow_hashref>

  $hash_ref = $sth->fetchrow_hashref;
  $hash_ref = $sth->fetchrow_hashref($name);

Fetches the next row of data and returns a hashref containing the name of the columns as
the keys and the data itself as the values. Any NULL value is returned as as undef value.

If there are no more rows or if an error occurs, the this method return undef.
You should check C<< $sth->err >> afterwards (or use the L</RaiseError> attribute)
to discover if the undef returned was due to an error.

The optional C<$name> argument should be either C<NAME>, C<NAME_lc> or C<NAME_uc>,
and indicates what sort of transformation to make to the keys in the hash.

=head3 B<fetchall_arrayref>

  $tbl_ary_ref = $sth->fetchall_arrayref();
  $tbl_ary_ref = $sth->fetchall_arrayref( $slice );
  $tbl_ary_ref = $sth->fetchall_arrayref( $slice, $max_rows );

Returns a reference to an array of arrays that contains all the remaining rows
to be fetched from the statement handle. If there are no more rows, an empty arrayref
will be returned. If an error occurs, the data read in so far will be returned.
Because of this, you should always check C<< $sth->err >> after calling this method,
unless L</RaiseError> has been enabled.

エラーが起こった場合でも、エラーが起こるまでに読み込まれたデータはそのまま返されます。
このため、L</RaiseError> を有効にしていない場合には、このメソッドを呼んだ後で、常に
C<< $sth->err >> をチェックするべきです。

If C<$slice> is an array reference, fetchall_arrayref uses the L</fetchrow_arrayref>
method to fetch each row as an array ref. If the C<$slice> array is not empty then
it is used as a slice to select individual columns by perl array index number
(starting at 0, unlike column and parameter numbers which start at 1).

With no parameters, or if $slice is undefined,
fetchall_arrayref acts as if passed an empty array ref.

If C<$slice> is a hash reference, fetchall_arrayref uses L</fetchrow_hashref>
to fetch each row as a hash reference.

See the DBI documentation for a complete discussion.

=head3 B<fetchall_hashref>

  $hash_ref = $sth->fetchall_hashref( $key_field );

Returns a hashref containing all rows to be fetched from the statement handle.
See the DBI documentation for a full discussion.

=head3 B<finish>

  $rv = $sth->finish;

Indicates to DBI that you are finished with the statement handle and are not going
to use it again. Only needed when you have not fetched all the possible rows.

=head3 B<rows>

  $rv = $sth->rows;

Returns the number of rows returned by the last query. In contrast to many other DBD modules, 
the number of rows is available immediately after calling C<< $sth->execute >>. Note that 
the L</execute> method itself returns the number of rows itself, which means that this 
method is rarely needed.

=head3 B<bind_col>

  $rv = $sth->bind_col($column_number, \$var_to_bind);
  $rv = $sth->bind_col($column_number, \$var_to_bind, \%attr );
  $rv = $sth->bind_col($column_number, \$var_to_bind, $bind_type );

Binds a Perl variable and/or some attributes to an output column of a SELECT statement. 
Column numbers count up from 1. You do not need to bind output columns in order to fetch data.

See the DBI documentation for a discussion of the optional parameters C<\%attr> and C<$bind_type>

=head3 B<bind_columns>

  $rv = $sth->bind_columns(@list_of_refs_to_vars_to_bind);

Calls the L</bind_col> method for each column in the SELECT statement, using the supplied list.

=head3 B<dump_results>

  $rows = $sth->dump_results($maxlen, $lsep, $fsep, $fh);

Fetches all the rows from the statement handle, calls C<DBI::neat_list> for each row, and 
prints the results to C<$fh> (which defaults to F<STDOUT>).
Rows are separated by C<$lsep> (which defaults to a newline).
Columns are separated by C<$fsep> (which defaults to a comma).
The C<$maxlen> controls how wide the output can be, and defaults to 35.

This method is designed as a handy utility for prototyping and testing queries. Since it uses 
"neat_list" to format and edit the string for reading by humans, it is not recommended 
for data transfer applications.

=head3 B<blob_read>

  $blob = $sth->blob_read($id, $offset, $len);

Supported by DBD::Pg. This method is implemented by DBI but not
currently documented by DBI, so this method might change.

This method seems to be heavily influenced by the current implementation of
blobs in Oracle. Nevertheless we try to be as compatible as possible. Whereas
Oracle suffers from the limitation that blobs are related to tables and every
table can have only one blob (datatype LONG), PostgreSQL handles its blobs
independent of any table by using so-called object identifiers. This explains
why the C<blob_read> method is blessed into the STATEMENT package and not part of
the DATABASE package. Here the field parameter has been used to handle this
object identifier. The offset and len parameters may be set to zero, in which
case the whole blob is fetched at once.

See also the PostgreSQL-specific functions concerning blobs, which are
available via the C<func> interface.

For further information and examples about blobs, please read the chapter
about Large Objects in the PostgreSQL Programmer's Guide at
L<http://www.postgresql.org/docs/current/static/largeobjects.html>.

=head2 Statement Handle Attributes

=head3 B<NUM_OF_FIELDS> (integer, read-only)

Returns the number of columns returned by the current statement.
A number will only be returned for SELECT statements, for SHOW statements
(which always return C<1>), and for INSERT, UPDATE, and DELETE statements which
contain a RETURNING clause.
This method returns undef if called before C<execute()>.

=head3 B<NUM_OF_PARAMS> (integer, read-only)

Returns the number of placeholders in the current statement.

=head3 B<NAME> (arrayref, read-only)

Returns an arrayref of column names for the current statement. This 
method will only work for SELECT statements, for SHOW statements, and for 
INSERT, UPDATE, and DELETE statements which contain a RETURNING clause.
This method returns undef if called before C<execute()>.

=head3 B<NAME_lc> (arrayref, read-only)

The same as the C<NAME> attribute, except that all column names are forced to lower case.

=head3 B<NAME_uc>  (arrayref, read-only)

The same as the C<NAME> attribute, except that all column names are forced to upper case.

=head3 B<NAME_hash> (hashref, read-only)

Similar to the C<NAME> attribute, but returns a hashref of column names instead of an arrayref.
The names of the columns are the keys of the hash, and the values represent the order
in which the columns are returned, starting at 0.
This method returns undef if called before C<execute()>.

=head3 B<NAME_lc_hash> (hashref, read-only)

The same as the C<NAME_hash> attribute, except that all column names are forced to lower case.

=head3 B<NAME_uc_hash> (hashref, read-only)

The same as the C<NAME_hash> attribute, except that all column names are forced to lower case.

=head3 B<TYPE> (arrayref, read-only)

Returns an arrayref indicating the data type for each column in the statement. 
This method returns undef if called before C<execute()>.

=head3 B<PRECISION> (arrayref, read-only)

Returns an arrayref of integer values for each column returned by the statement. 
The number indicates the precision for C<NUMERIC> columns, the size in number of 
characters for C<CHAR> and C<VARCHAR> columns, and for all other types of columns 
it returns the number of I<bytes>.
This method returns undef if called before C<execute()>.

=head3 B<SCALE> (arrayref, read-only)

Returns an arrayref of integer values for each column returned by the statement. The number 
indicates the scale of the that column. The only type that will return a value is C<NUMERIC>.
This method returns undef if called before C<execute()>.

=head3 B<NULLABLE> (arrayref, read-only)

Returns an arrayref of integer values for each column returned by the statement. The number 
indicates if the column is nullable or not. 0 = not nullable, 1 = nullable, 2 = unknown. 
This method returns undef if called before C<execute()>.

=head3 B<Database> (dbh, read-only)

Returns the database handle this statement handle was created from.

=head3 B<ParamValues> (hash ref, read-only)

Returns a reference to a hash containing the values currently bound to placeholders.
If the "named parameters" type of placeholders are being used (such as ":foo"),
then the keys of the hash will be the names of the placeholders (without the colon).
If the "dollar sign numbers" type of placeholders are being used, the keys of the hash will 
be the numbers, without the dollar signs. If the "question mark" type is used,
integer numbers will be returned, starting at one and increasing for every placeholder.

If this method is called before L</execute>, the literal values passed in are returned.
If called after L</execute>, then the quoted versions of the values are returned.

=head3 B<ParamTypes> (hash ref, read-only)

Returns a reference to a hash containing the type names currently bound to placeholders.
The keys are the same as returned by the ParamValues method.
The values are hashrefs containing a single key value pair, in which the key is either
'TYPE' if the type has a generic SQL equivalent, and 'pg_type' if the type can 
only be expressed by a Postgres type. The value is the internal number corresponding to
the type originally passed in.
(Placeholders that have not yet been bound will return undef as the value).
This allows the output of ParamTypes to be passed back to the L</bind_param> method.

=head3 B<Statement> (string, read-only)

Returns the statement string passed to the most recent "prepare" method called in
this database handle, even if that method failed.
This is especially useful where "RaiseError" is enabled and the exception handler
checks $@ and sees that a C<prepare> method call failed.

=head3 B<pg_current_row> (integer, read-only)

DBD::Pg specific attribute. Returns the number of the tuple (row) that was
most recently fetched. Returns zero before and after fetching is performed.

=head3 B<pg_numbound> (integer, read-only)

DBD::Pg specific attribute. Returns the number of placeholders
that are currently bound (via bind_param).

=head3 B<pg_bound> (hashref, read-only)

DBD::Pg specific attribute. Returns a hash of all named placeholders. The
key is the name of the placeholder, and the value is a 0 or a 1, indicating if
the placeholder has been bound yet (e.g. via bind_param)

=head3 B<pg_size> (arrayref, read-only)

DBD::Pg specific attribute. It returns a reference to an array of integer
values for each column. The integer shows the size of the column in
bytes. Variable length columns are indicated by -1.

=head3 B<pg_type> (arrayref, read-only)

DBD::Pg specific attribute. It returns a reference to an array of strings
for each column. The string shows the name of the data_type.

=head3 B<pg_segments> (arrayref, read-only)

DBD::Pg specific attribute. Returns an arrayref of the query split on the 
placeholders.

=head3 B<pg_oid_status> (integer, read-only)

DBD::Pg specific attribute. It returns the OID of the last INSERT command.

=head3 B<pg_cmd_status> (integer, read-only)

DBD::Pg specific attribute. It returns the type of the last
command. Possible types are: "INSERT", "DELETE", "UPDATE", "SELECT".

=head3 B<pg_direct> (boolean)

DBD::Pg specific attribute. Default is false. If true, the query is passed 
directly to the backend without parsing for placeholders.

=head3 B<pg_prepare_now> (boolean)

DBD::Pg specific attribute. Default is off. If true, the query will be immediately 
prepared, rather than waiting for the L</execute> call.

=head3 B<pg_prepare_name> (string)

DBD::Pg specific attribute. Specifies the name of the prepared statement to use for this 
statement handle. Not normally needed, see the section on the L</prepare> method for 
more information.

=head3 B<pg_server_prepare> (integer)

DBD::Pg specific attribute. Indicates if DBD::Pg should attempt to use server-side 
prepared statements for this statement handle. The default value, 1, indicates that prepared 
statements should be used whenever possible. See the section on the L</prepare> method for 
more information.

=head3 B<pg_placeholder_dollaronly> (boolean)

DBD::Pg specific attribute. Defaults to off. When true, question marks inside of the query 
being prepared are not treated as placeholders.
Useful for statements that contain unquoted question marks, such as geometric operators.

=head3 B<pg_async> (integer)

DBD::Pg specific attribute. Indicates the current behavior for asynchronous queries.
See the section on L</Asynchronous Constants> for more information.

=head3 B<RowsInCache>

Not used by DBD::Pg

=head3 B<RowCache>

Not used by DBD::Pg

=head3 B<CursorName>

Not used by DBD::Pg. See the note about L</Cursors> elsewhere in this document.

=head1 FURTHER INFORMATION

=head2 Transactions

Transaction behavior is controlled via the L</AutoCommit> attribute. For a
complete definition of C<AutoCommit> please refer to the DBI documentation.

According to the DBI specification the default for C<AutoCommit> is a true
value. In this mode, any change to the database becomes valid immediately. Any
C<BEGIN>, C<COMMIT> or C<ROLLBACK> statements will be rejected. DBD::Pg
implements C<AutoCommit> by issuing a C<BEGIN> statement immediately before
executing a statement, and a C<COMMIT> afterwards. Note that preparing a 
statement is not always enough to trigger the first C<BEGIN>, as the actual 
C<PREPARE> is usually postponed until the first call to L</execute>.

=head2 Savepoints

PostgreSQL version 8.0 introduced the concept of savepoints, which allows 
transactions to be rolled back to a certain point without affecting the 
rest of the transaction. DBD::Pg encourages using the following methods to 
control savepoints:

=head3 C<pg_savepoint>

Creates a savepoint. This will fail unless you are inside of a transaction. The 
only argument is the name of the savepoint. Note that PostgreSQL DOES allow 
multiple savepoints with the same name to exist.

  $dbh->pg_savepoint("mysavepoint");

=head3 C<pg_rollback_to>

Rolls the database back to a named savepoint, discarding any work performed after 
that point. If more than one savepoint with that name exists, rolls back to the 
most recently created one.

  $dbh->pg_rollback_to("mysavepoint");

=head3 C<pg_release>

Releases (or removes) a named savepoint. If more than one savepoint with that name 
exists, it will only destroy the most recently created one. Note that all savepoints 
created after the one being released are also destroyed.

  $dbh->pg_release("mysavepoint");

=head2 Asynchronous Queries

It is possible to send a query to the backend and have your script do other work while
the query is running on the backend. Both queries sent by the L</do> method,
and by the L</execute> method can be sent asynchronously.
(NOTE: This will only work if DBD::Pg has been compiled against Postgres libraries 
of version 8.0 or greater) The basic usage is as follows:

  use DBD::Pg ':async';

  print "Async do() example:\n";
  $dbh->do("SELECT long_running_query()", {pg_async => PG_ASYNC});
  do_something_else();
  {
    if ($dbh->pg_ready()) {
      $res = $pg_result();
      print "Result of do(): $res\n";
    }
    print "Query is still running...\n";
    if (cancel_request_received) {
      $dbh->pg_cancel();
    }
    sleep 1;
    redo;
  }

  print "Async prepare/execute example:\n";
  $sth = $dbh->prepare("SELECT long_running_query(1)", {pg_async => PG_ASYNC});
  $sth->execute();

  ## Changed our mind, cancel and run again:
  $sth = $dbh->prepare("SELECT 678", {pg_async => PG_ASYNC + PG_OLDQUERY_CANCEL});
  $sth->execute();

  do_something_else();

  if (!$sth->pg_ready) {
    do_another_thing();
  }

  ## We wait until it is done, and get the result:
  $res = $dbh->pg_result();

=head3 Asynchronous Constants

(非同期関連の定数)

There are currently three asynchronous constants exported by DBD::Pg.
You can import all of them by putting either of these at the top of your script:

  use DBD::Pg;

  use DBD::Pg ':async';

You may also use the numbers instead of the constants, but using the constants is
recommended as it makes your script more readable.

=over 4

=item PG_ASYNC

This is a constant for the number 1. It is passed to either the L</do> or the
L</prepare> method as a value to the pg_async key and indicates that the query
should be sent asynchronously.

=item PG_OLDQUERY_CANCEL

This is a constant for the number 2. When passed to either the L</do> or the
L</prepare> method, it causes any currently running asynchronous query to be cancelled
and rolled back. It has no effect if no asynchronous query is currently running.

=item PG_OLDQUERY_WAIT

This is a constant for the number 4. When passed to either the L</do> or the L</prepare> method,
it waits for any currently running asynchronous query to complete.
It has no effect if there is no asynchronous query currently running.

=back

=head3 Asynchronous Methods

=over 4

=item B<pg_cancel>

This database-level method attempts to cancel any currently running asynchronous query.
It returns true if the cancel succeeded, and false otherwise.
Note that a query that has finished before this method is executed will also return false.
B<WARNING>: a successful cancellation may leave the database in an unusable state, 
so you may need to ROLLBACK or ROLLBACK TO a savepoint. As of version 2.17.0 of DBD::Pg,
rollbacks are not done automatically.

  $result = $dbh->pg_cancel();

=item B<pg_ready>

=begin original

This method can be called as a database handle method or (for convenience) as a
statement handle method. Both simply see if a previously issued asynchronous query
has completed yet. It returns true if the statement has finished, in which case you
should then call the L</pg_result> method. Calls to C<pg_ready()> should only be used
when you have other things to do while the query is running.
If you simply want to wait until the query is done, do not call pg_ready()
over and over, but simply call the pg_result() method.

=end original

このメソッドはデータベースハンドルメソッドとしても、
(簡便のため) ステートメントハンドルメソッドとしても呼ぶことができます。
どちらも、以前に発行した非同期クエリがもう完了したかどうかを返します。
クエリが完了していれば真を返します。(訳注: まだ完了していないときは偽を返します。)
C<pg_ready> が真を返した時は、次に L</pg_result> を呼ぶべきです。C<pg_ready()>
は、クエリが実行されている間に、あなたが何か他にやることがある場合にだけ呼ぶべきです。
クエリが完了するのを単に待ちたい時は、C<pg_ready()> を繰り返し呼ぶことはせず、単に
C<pg_result()> メソッドを呼んでください。

  my $time = 0;
  while (!$dbh->pg_ready) {
    print "Query is still running. Seconds: $time\n";
    $time++;
    sleep 1;
  }
  $result = $dbh->pg_result;

=item B<pg_result>

=begin original

This database handle method returns the results of a previously issued asynchronous query.
If the query is still running, this method will wait until it has finished.
The result returned is the number of rows: the same thing that would have been returned by
the asynchronous L</do> or L</execute> if it had been called without an asynchronous flag.

=end original

このデータベースハンドルのメソッドは、以前に発行した非同期クエリの result を返します。
クエリがまだ実行されている場合は、このメソッドは終了するのを待ちます。
ここで返される result は行数で、L</do> や L</execute> を非同期のフラグ無しで呼んだときに
返されるものと同じものです。

  $result = $dbh->pg_result;

=back

=head3 Asynchronous Examples

=begin original

Here are some working examples of asynchronous queries.
Note that we'll use the B<pg_sleep> function to emulate a long-running query.

=end original

これは、実際に機能する非同期クエリの例です。
時間のかかるクエリをエミュレートするために、B<pg_sleep>
関数を使用していることに注意してください。

=begin original

  use strict;
  use warnings;
  use Time::HiRes 'sleep';
  use DBD::Pg ':async';

  my $dbh = DBI->connect('dbi:Pg:dbname=postgres', 'postgres', '', {AutoCommit=>0,RaiseError=>1});

  ## Kick off a long running query on the first database:
  my $sth = $dbh->prepare("SELECT pg_sleep(?)", {pg_async => PG_ASYNC});
  $sth->execute(5);

  ## While that is running, do some other things
  print "Your query is processing. Thanks for waiting\n";
  check_on_the_kids(); ## Expensive sub, takes at least three seconds.

  while (!$dbh->pg_ready) {
    check_on_the_kids();
    ## If the above function returns quickly for some reason, we add a small sleep
    sleep 0.1;
  }

  print "The query has finished. Gathering results\n";
  my $result = $sth->pg_result;
  print "Result: $result\n";
  my $info = $sth->fetchall_arrayref();

=end original

  use strict;
  use warnings;
  use Time::HiRes 'sleep';
  use DBD::Pg ':async';

  my $dbh = DBI->connect('dbi:Pg:dbname=postgres', 'postgres', '', {AutoCommit=>0,RaiseError=>1});

  ## 最初のデータベース上で時間のかかるクエリをキックオフ:
  my $sth = $dbh->prepare("SELECT pg_sleep(?)", {pg_async => PG_ASYNC});
  $sth->execute(5);

  ## クエリが処理されている間に、ほかの事をする
  print "Your query is processing. Thanks for waiting\n";
  check_on_the_kids(); ## 少なくとも 3 秒はかかる高価なサブルーチン

  while (!$dbh->pg_ready) {
    check_on_the_kids();
    ## 何らかの理由で上の関数がすぐに戻ってきたときのために、少々 sleep を入れておく
    sleep 0.1;
  }

  print "The query has finished. Gathering results\n";
  my $result = $sth->pg_result;
  print "Result: $result\n";
  my $info = $sth->fetchall_arrayref();

=begin original

Without asynchronous queries, the above script would take about 8 seconds to run:
five seconds waiting for the execute to finish, then three for the check_on_the_kids()
function to return. With asynchronous queries, the script takes about 6 seconds to run,
and gets in two iterations of check_on_the_kids in the process.

=end original

非同期クエリを使用しなければ、上のスクリプトは約 8 秒かかります: execute が終わるのを
5 秒待ち、それから関数 check_on_the_kids() が戻るのに 3 秒です。非同期クエリを使うと約
6 秒かかり、処理の中で check_on_the_kids を 2 回実行します。

=begin original

Here's an example showing the ability to cancel a long-running query.
Imagine two slave databases in different geographic locations over a slow network.
You need information as quickly as possible, so you query both at once.
When you get an answer, you tell the other one to stop working on your query, 
as you don't need it anymore.

=end original

次は、時間のかかるクエリをキャンセルできることを示す例です。
地理的に異なる場所にある2つの slave データベースが、遅いネットワークの先にあると想像してください。
あなたは、できるだけ速やかに情報を取り出さなければならないので、両方のサーバに対して、
一度にクエリを発行します。どちらかのサーバから回答を得たとき、
あなたはもう一方のサーバに対して、もう必要ないので処理をやめるように伝えます。

  use strict;
  use warnings;
  use Time::HiRes 'sleep';
  use DBD::Pg ':async';

  my $dbhslave1 = DBI->connect('dbi:Pg:dbname=postgres;host=slave1', 'postgres', '', {AutoCommit=>0,RaiseError=>1});
  my $dbhslave2 = DBI->connect('dbi:Pg:dbname=postgres;host=slave2', 'postgres', '', {AutoCommit=>0,RaiseError=>1});

  $SQL = "SELECT count(*) FROM largetable WHERE flavor='blueberry'";

  my $sth1 = $dbhslave1->prepare($SQL, {pg_async => PG_ASYNC});
  my $sth2 = $dbhslave2->prepare($SQL, {pg_async => PG_ASYNC});

  $sth1->execute();
  $sth2->execute();

  my $winner;
  while (!defined $winner) {
    if ($sth1->pg_ready) {
      $winner = 1;
    }
    elsif ($sth2->pg_ready) {
      $winner = 2;
    }
    Time::HiRes::sleep 0.05;
  }

  my $count;
  if ($winner == 1) {
    $sth2->pg_cancel();
    $sth1->pg_result();
    $count = $sth1->fetchall_arrayref()->[0][0];
  }
  else {
    $sth1->pg_cancel();
    $sth2->pg_result();
    $count = $sth2->fetchall_arrayref()->[0][0];
  }

=head2 Array support

=begin original

DBD::Pg allows arrays (as arrayrefs) to be passed in to both 
the L</quote> and the L</execute> methods. In both cases, the array is 
flattened into a string representing a Postgres array.

=end original

DBD::Pg は、L</quote> と L</execute> のどちらのメソッドにも配列を(リファレンスで)
渡すことを許しています。どちらの場合でも、渡された配列は Postgres
の配列を表す1つの文字列に平坦化されます。

=begin original

When fetching rows from a table that contains a column with an 
array type, the result will be passed back to your script as an arrayref.

=end original

配列型のカラムを含むテーブルの行を fetch すると、結果は Perl の arrayref
としてあなたのスクリプトに渡されます。

=begin original

To turn off the automatic parsing of returned arrays into arrayrefs, 
you can set the attribute L<pg_expand_array|/pg_expand_array_(boolean)>, which is true by default.

=end original

この「Postgres の配列を Perl の arrayref に展開する」という自動的な処理をやめさせたいときは
L<pg_expand_array|/pg_expand_array_(boolean)> 属性を偽に設定してください。
この値はデフォルトでは真です。

  $dbh->{pg_expand_array} = 0;

(訳注: Perl の配列は添え字が 0 から始まりますが、Postgresでは 1
から始まることに注意が必要です。いずれにせよ、配列の最初の要素は、
配列の最初の要素として扱われます。)

=head2 COPY support

DBD::Pg allows for quick (bulk) reading and storing of data by using 
the B<COPY> command. The basic process is to use C<< $dbh->do >> to issue a 
COPY command, and then to either add rows using L</pg_putcopydata>, or to 
read them by using L</pg_getcopydata>.

The first step is to put the server into "COPY" mode. This is done by 
sending a complete COPY command to the server, by using the L</do> method. 
For example:

  $dbh->do("COPY foobar FROM STDIN");

This would tell the server to enter a COPY IN mode (yes, that's confusing, but 
the I<mode> is COPY IN because of the I<command> COPY FROM). It is now ready to 
receive information via the L</pg_putcopydata> method. The complete syntax of the 
COPY command is more complex and not documented here: the canonical 
PostgreSQL documentation for COPY can be found at:

http://www.postgresql.org/docs/current/static/sql-copy.html

Once a COPY command has been issued, no other SQL commands are allowed 
until L</pg_putcopyend> has been issued (for COPY FROM), or the final 
L</pg_getcopydata> has been called (for COPY TO).

Note: All other COPY methods (pg_putline, pg_getline, etc.) are now 
heavily deprecated in favor of the pg_getcopydata, pg_putcopydata, and 
pg_putcopyend methods.

=head3 B<pg_getcopydata>

Used to retrieve data from a table after the server has been put into a 
COPY OUT mode by calling "COPY tablename TO STDOUT". Data is always returned 
one data row at a time. The first argument to pg_getcopydata 
is the variable into which the data will be stored (this variable should not 
be undefined, or it may throw a warning, although it may be a reference). The 
pg_gecopydata method returns a number greater than 1 indicating the new size of 
the variable, or a -1 when the COPY has finished. Once a -1 has been returned, no 
other action is necessary, as COPY mode will have already terminated. Example:

  $dbh->do("COPY mytable TO STDOUT");
  my @data;
  my $x=0;
  1 while $dbh->pg_getcopydata($data[$x++]) >= 0;

There is also a variation of this method called B<pg_getcopydata_async>, which, 
as the name suggests, returns immediately. The only difference from the original 
method is that this version may return a 0, indicating that the row is not 
ready to be delivered yet. When this happens, the variable has not been changed, 
and you will need to call the method again until you get a non-zero result.
(Data is still always returned one data row at a time.)

=head3 B<pg_putcopydata>

Used to put data into a table after the server has been put into COPY IN mode 
by calling "COPY tablename FROM STDIN". The only argument is the data you want 
inserted. Issue a pg_putcopyend() when you have added all your rows.

The default delimiter is a tab character, but this can be changed in 
the COPY statement. Returns a 1 on successful input. Examples:

  ## Simple example:
  $dbh->do("COPY mytable FROM STDIN");
  $dbh->pg_putcopydata("123\tPepperoni\t3\n");
  $dbh->pg_putcopydata("314\tMushroom\t8\n");
  $dbh->pg_putcopydata("6\tAnchovies\t100\n");
  $dbh->pg_putcopyend();

  ## This example uses explicit columns and a custom delimiter
  $dbh->do("COPY mytable(flavor, slices) FROM STDIN WITH DELIMITER '~'");
  $dbh->pg_putcopydata("Pepperoni~123\n");
  $dbh->pg_putcopydata("Mushroom~314\n");
  $dbh->pg_putcopydata("Anchovies~6\n");
  $dbh->pg_putcopyend();

=head3 B<pg_putcopyend>

When you are finished with pg_putcopydata, call pg_putcopyend to let the server know 
that you are done, and it will return to a normal, non-COPY state. Returns a 1 on 
success. This method will fail if called when not in COPY IN mode.

=head2 Large Objects

DBD::Pg supports all largeobject functions provided by libpq via the
C<< $dbh->pg_lo* >> methods. Please note that access to a large object, even read-only 
large objects, must be put into a transaction.

=head2 Cursors

Although PostgreSQL supports cursors, they have not been used in the current
implementation. When DBD::Pg was created, cursors in PostgreSQL could only be
used inside a transaction block. Because only one transaction block at a time
is allowed, this would have implied the restriction not to use any nested
C<SELECT> statements. Therefore the L</execute> method fetches all data at
once into data structures located in the front-end application. This fact
must to be considered when selecting large amounts of data!

You can use cursors in your application, but you'll need to do a little
work. First you must declare your cursor. Now you can issue queries against
the cursor, then select against your queries. This typically results in a
double loop, like this:

  # WITH HOLD is not needed if AutoCommit is off
  $dbh->do("DECLARE csr CURSOR WITH HOLD FOR $sql");
  while (1) {
    my $sth = $dbh->prepare("fetch 1000 from csr");
    $sth->execute;
    last if 0 == $sth->rows;

    while (my $row = $sth->fetchrow_hashref) {
      # Do something with the data.
    }
  }
  $dbh->do("CLOSE csr");

=head2 Datatype bool

The current implementation of PostgreSQL returns 't' for true and 'f' for false.
From the Perl point of view, this is a rather unfortunate choice.
DBD::Pg therefore translates the result for the C<BOOL> data type in a Perlish manner:
'f' becomes the number C<0> and 't' becomes the number C<1>. This way the application
does not have to check the database-specific returned values for the data-type C<BOOL>
because Perl treats C<0> as false and C<1> as true.
You may set the L<pg_bool_tf|/pg_bool_tf_(boolean)> attribute to a true value to change
the values back to 't' and 'f' if you wish.

Boolean values can be passed to PostgreSQL as TRUE, 't', 'true', 'y', 'yes' or
'1' for true and FALSE, 'f', 'false', 'n', 'no' or '0' for false.

=head2 Schema support

The PostgreSQL schema concept may differ from those of other databases. In a nutshell,
a schema is a named collection of objects within a single database. Please refer to the
PostgreSQL documentation for more details:

L<http://www.postgresql.org/docs/current/static/ddl-schemas.html>

DBD::Pg does not provide explicit support for PostgreSQL schemas.  However, schema
functionality may be used without any restrictions by explicitly addressing schema objects, e.g.

  my $res = $dbh->selectall_arrayref("SELECT * FROM my_schema.my_table");

or by manipulating the schema search path with C<SET search_path>, e.g.

  $dbh->do("SET search_path TO my_schema, public");

=head1 SEE ALSO

=for text The B<DBI> module.

=for html <a href="http://search.cpan.org/~timb/DBI/DBI.pm">The DBI module</a>

=head1 BUGS

To report a bug, or view the current list of bugs, please visit 
http://rt.cpan.org/Public/Dist/Display.html?Name=DBD-Pg

=head1 AUTHORS

DBI by Tim Bunce L<http://www.tim.bunce.name>

The original DBD-Pg was by Edmund Mergl (E.Mergl@bawue.de) and Jeffrey W. Baker
(jwbaker@acm.org). Major developers include David Wheeler <david@justatheory.com>, Jason
Stewart <jason@openinformatics.com>, Bruce Momjian <pgman@candle.pha.pa.us>, and 
Greg Sabino Mullane <greg@turnstep.com>, with help from many others: see the F<Changes>
file for a complete list.

Parts of this package were originally copied from DBI and DBD-Oracle.

B<Mailing List>

The current maintainers may be reached through the 'dbd-pg' mailing list:
<dbd-pg@perl.org>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 1994-2010, Greg Sabino Mullane

This module (DBD::Pg) is free software; you can redistribute it and/or modify it 
under the same terms as Perl 5.10.0. For more details, see the full text of the 
licenses in the directory LICENSES.

=head1 訳者メモ

一つ目、ひとつめ、一つ目

二つめ、ふたつめ、二つ目

pgsql-doc-ja では、「1つ目」、「2つ目」で統一されているぽい。

できます、出来ます

トレース・フラグ

トレース･フラグ

有効、無効、on off

バージョン、version

可搬性、ポータビリティ

=begin meta

Translate: Atsushi SUGAWARA <peanutsjamjam@gmail.com>

=end meta

=cut
